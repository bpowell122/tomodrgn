
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tomodrgn.analysis &#8212; tomoDRGN 0.2.3.dev328 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../../_static/documentation_options.js?v=d6c7774d"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/tomodrgn/analysis';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">tomoDRGN v0.2.3.dev328</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../overview/index.html">
    Overview
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../tutorials/index.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../command_usage/index.html">
    Command Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/index.html">
    API
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../overview/index.html">
    Overview
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../tutorials/index.html">
    Tutorials
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../command_usage/index.html">
    Command Usage
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api/index.html">
    API
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">tomodrgn.analysis</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for tomodrgn.analysis</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions for analysis of particle metadata: index, pose, ctf, latent embedding, label, tomogram spatial context, etc.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span> <span class="k">as</span> <span class="n">dt</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">import</span> <span class="nn">matplotlib.figure</span>
<span class="kn">import</span> <span class="nn">matplotlib.gridspec</span> <span class="k">as</span> <span class="nn">gridspec</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">plotly.callbacks</span>
<span class="kn">import</span> <span class="nn">plotly.colors</span> <span class="k">as</span> <span class="nn">pl_colors</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objs</span> <span class="k">as</span> <span class="nn">go</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="c1"># noinspection PyPackageRequirements</span>
<span class="kn">import</span> <span class="nn">umap</span>
<span class="kn">from</span> <span class="nn">adjustText</span> <span class="kn">import</span> <span class="n">adjust_text</span>
<span class="kn">from</span> <span class="nn">ipywidgets</span> <span class="kn">import</span> <span class="n">interactive</span><span class="p">,</span> <span class="n">widgets</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">Colormap</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="kn">import</span> <span class="n">TSNE</span>
<span class="kn">from</span> <span class="nn">sklearn.mixture</span> <span class="kn">import</span> <span class="n">GaussianMixture</span>

<span class="kn">from</span> <span class="nn">tomodrgn</span> <span class="kn">import</span> <span class="n">utils</span><span class="p">,</span> <span class="n">mrc</span><span class="p">,</span> <span class="n">starfile</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">log</span>


<div class="viewcode-block" id="parse_loss">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.parse_loss.html#tomodrgn.analysis.parse_loss">[docs]</a>
<span class="k">def</span> <span class="nf">parse_loss</span><span class="p">(</span><span class="n">run_log</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse total loss at each epoch from run.log output.</span>

<span class="sd">    :param run_log: Path to run.log output file.</span>
<span class="sd">    :return: array of total loss at each epoch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">run_log</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="c1"># every epoch is reported in log with &#39;=====&gt;&#39; line</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span> <span class="k">if</span> <span class="s1">&#39;=====&gt;&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]</span>

    <span class="c1"># total loss is 4th-to-last word, and is ended by semicolon</span>
    <span class="n">total_loss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">4</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">total_loss</span></div>



<div class="viewcode-block" id="parse_all_losses">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.parse_all_losses.html#tomodrgn.analysis.parse_all_losses">[docs]</a>
<span class="k">def</span> <span class="nf">parse_all_losses</span><span class="p">(</span><span class="n">run_log</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse MSE, KLD, and total loss at each epoch from run.log output.</span>

<span class="sd">    :param run_log: Path to run.log output file.</span>
<span class="sd">    :return: tuple of arrays for MSE loss, KLD loss, and total loss, at each epoch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">run_log</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lines</span> <span class="k">if</span> <span class="s1">&#39;====&gt;&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>

    <span class="n">loss_mse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">10</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">loss_kld</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">13</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">loss_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">17</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">loss_mse</span><span class="p">,</span> <span class="n">loss_kld</span><span class="p">,</span> <span class="n">loss_total</span></div>



<span class="c1">###################################</span>
<span class="c1"># Latent dimensionality reduction #</span>
<span class="c1">###################################</span>


<div class="viewcode-block" id="run_pca">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.run_pca.html#tomodrgn.analysis.run_pca">[docs]</a>
<span class="k">def</span> <span class="nf">run_pca</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">PCA</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run principal component analysis on the latent embeddings.</span>

<span class="sd">    :param z: array of latent embeddings, shape (nptcls, zdim)</span>
<span class="sd">    :param verbose: if True, log additional information to STDOUT</span>
<span class="sd">    :return: tuple of principal-component-transformed latent embeddings and the fit sklearn PCA object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># run PCA keeping zdim components (i.e., all components)</span>
    <span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Explained variance ratio:&#39;</span><span class="p">)</span>
        <span class="n">log</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pc</span><span class="p">,</span> <span class="n">pca</span></div>



<div class="viewcode-block" id="get_pc_traj">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.get_pc_traj.html#tomodrgn.analysis.get_pc_traj">[docs]</a>
<span class="k">def</span> <span class="nf">get_pc_traj</span><span class="p">(</span><span class="n">pca</span><span class="p">:</span> <span class="n">PCA</span><span class="p">,</span>
                <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                <span class="n">sampling_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample latent embeddings along specified principal component `dim` at coordininates in PC-space specified by `sampling_points`.</span>
<span class="sd">    Note that sampled points are precisely on-pc-axis and are therefore off-data.</span>

<span class="sd">    :param pca: pre-fit sklearn PCA object from `analysis.run_pca`</span>
<span class="sd">    :param dim: PC dimension for the trajectory (1-based index)</span>
<span class="sd">    :param sampling_points: array of points to sample along specified principal component.</span>
<span class="sd">    :return: array of latent embedding values along PC, shape (len(sampling_points), zdim).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sanity check inputs</span>
    <span class="n">zdim</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">get_params</span><span class="p">()[</span><span class="s1">&#39;n_components&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">dim</span> <span class="o">&lt;=</span> <span class="n">zdim</span>

    <span class="c1"># initialize an array of points to inverse transform from PC space to latent space</span>
    <span class="n">traj_pca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sampling_points</span><span class="p">),</span> <span class="n">zdim</span><span class="p">))</span>
    <span class="c1"># only sampling points along `dim` axis, all other points for all other dims are 0</span>
    <span class="n">traj_pca</span><span class="p">[:,</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampling_points</span>

    <span class="c1"># inverse transform the points</span>
    <span class="n">ztraj_pca</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">traj_pca</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ztraj_pca</span></div>



<div class="viewcode-block" id="run_tsne">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.run_tsne.html#tomodrgn.analysis.run_tsne">[docs]</a>
<span class="k">def</span> <span class="nf">run_tsne</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
             <span class="n">perplexity</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1_000</span><span class="p">,</span>
             <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run t-SNE dimensionality reduction on latent embeddings.</span>

<span class="sd">    :param z: array of latent embeddings, shape (nptcls, zdim)</span>
<span class="sd">    :param n_components: number of dimensions in the embedded t-SNE space, passed to sklearn.manifold.TSNE</span>
<span class="sd">    :param perplexity: related to the number of nearest neighbors that is used in other manifold learning algorithms, passed to sklearn.manifold.TSNE</span>
<span class="sd">    :param random_state: random state for reproducible runs, passed to sklearn.manifold.TSNE</span>
<span class="sd">    :param kwargs: additional key word arguments passed to sklearn.manifold.TSNE</span>
<span class="sd">    :return: array of t-SNE embeddings, shape (len(z), n_components)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sanity check inputs</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10_000</span><span class="p">:</span>
        <span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="si">}</span><span class="s1"> datapoints &gt; </span><span class="si">{</span><span class="mi">10_000</span><span class="si">}</span><span class="s1">. This may take a while...&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">perplexity</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

    <span class="c1"># perform embedding</span>
    <span class="n">z_embedded</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span> <span class="n">perplexity</span><span class="o">=</span><span class="n">perplexity</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z_embedded</span></div>



<div class="viewcode-block" id="run_umap">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.run_umap.html#tomodrgn.analysis.run_umap">[docs]</a>
<span class="k">def</span> <span class="nf">run_umap</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
             <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run UMAP dimensionality reduction on latent embeddings.</span>

<span class="sd">    :param z: array of latent embeddings, shape (nptcls, zdim)</span>
<span class="sd">    :param random_state: random state for reproducible runs, passed to umap.UMAP</span>
<span class="sd">    :param kwargs: additional key word arguments passed to umap.UMAP</span>
<span class="sd">    :return: array of UMAP embeddings, shape (len(z), 2), and fit reducer object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># perform embedding</span>
    <span class="n">reducer</span> <span class="o">=</span> <span class="n">umap</span><span class="o">.</span><span class="n">UMAP</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">z_embedded</span> <span class="o">=</span> <span class="n">reducer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z_embedded</span><span class="p">,</span> <span class="n">reducer</span></div>



<span class="c1">#####################</span>
<span class="c1"># Latent clustering #</span>
<span class="c1">#####################</span>


<div class="viewcode-block" id="cluster_kmeans">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.cluster_kmeans.html#tomodrgn.analysis.cluster_kmeans">[docs]</a>
<span class="k">def</span> <span class="nf">cluster_kmeans</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">n_clusters</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                   <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">on_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="n">reorder</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cluster latent embeddings using k-means clustering.</span>
<span class="sd">    If reorder=True, reorders clusters according to agglomerative clustering of cluster centers</span>

<span class="sd">    :param z: array of latent embeddings, shape (nptcls, zdim)</span>
<span class="sd">    :param n_clusters: number of clusters to form, passed to sklearn.cluster.KMeans</span>
<span class="sd">    :param random_state: random state for reproducible runs, passed to sklearn.cluster.KMeans</span>
<span class="sd">    :param on_data: adjust cluster centers to nearest point on the data manifold `z`</span>
<span class="sd">    :param reorder: reorder clusters according to agglomerative clustering of cluster centers</span>
<span class="sd">    :param kwargs: additional key word arguments passed to sklearn.cluster.KMeans</span>
<span class="sd">    :return: array of cluster labels shape (len(z)), array of cluster centers shape (n_clusters, zdim)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># perform clustering</span>
    <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                    <span class="n">init</span><span class="o">=</span><span class="s1">&#39;k-means++&#39;</span><span class="p">,</span>
                    <span class="n">n_init</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>

    <span class="c1"># resample cluster centers to nearest on-data points within input latent embeddings</span>
    <span class="k">if</span> <span class="n">on_data</span><span class="p">:</span>
        <span class="n">centers</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_nearest_point</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
                                       <span class="n">query</span><span class="o">=</span><span class="n">centers</span><span class="p">)</span>

    <span class="c1"># reorder clusters by agglomerative clustering distance</span>
    <span class="k">if</span> <span class="n">reorder</span><span class="p">:</span>
        <span class="c1"># clustermap generation</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">clustermap</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>

        <span class="c1"># reindexing centers and labels</span>
        <span class="n">reordered</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">dendrogram_row</span><span class="o">.</span><span class="n">reordered_ind</span>
        <span class="n">centers</span> <span class="o">=</span> <span class="n">centers</span><span class="p">[</span><span class="n">reordered</span><span class="p">]</span>
        <span class="n">reorder_label_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">old_label</span><span class="p">:</span> <span class="n">new_label</span> <span class="k">for</span> <span class="n">new_label</span><span class="p">,</span> <span class="n">old_label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reordered</span><span class="p">)}</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">reorder_label_mapping</span><span class="p">[</span><span class="n">old_label</span><span class="p">]</span> <span class="k">for</span> <span class="n">old_label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">centers</span></div>



<div class="viewcode-block" id="cluster_gmm">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.cluster_gmm.html#tomodrgn.analysis.cluster_gmm">[docs]</a>
<span class="k">def</span> <span class="nf">cluster_gmm</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                <span class="n">n_components</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                <span class="n">random_state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">on_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cluster latent embeddings using a K-component full covariance Gaussian mixture model.</span>

<span class="sd">    :param z: array of latent embeddings, shape (nptcls, zdim)</span>
<span class="sd">    :param n_components: number of components to use in GMM, passed to sklearn.mixture.GaussianMixture</span>
<span class="sd">    :param random_state: random state for reproducible runs, passed to sklearn.cluster.KMeans</span>
<span class="sd">    :param on_data: adjust cluster centers to nearest point on the data manifold `z`</span>
<span class="sd">    :param kwargs: additional key word arguments passed to sklearn.mixture.GaussianMixture</span>
<span class="sd">    :return: array of cluster labels shape (len(z)), array of cluster centers shape (n_clusters, zdim)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># perform clustering</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">GaussianMixture</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">n_components</span><span class="p">,</span>
                          <span class="n">covariance_type</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span>
                          <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">means_</span>

    <span class="c1"># resample cluster centers to nearest on-data points within input latent embeddings</span>
    <span class="k">if</span> <span class="n">on_data</span><span class="p">:</span>
        <span class="n">centers</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_nearest_point</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
                                       <span class="n">query</span><span class="o">=</span><span class="n">centers</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">labels</span><span class="p">,</span> <span class="n">centers</span></div>



<div class="viewcode-block" id="get_nearest_point">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.get_nearest_point.html#tomodrgn.analysis.get_nearest_point">[docs]</a>
<span class="k">def</span> <span class="nf">get_nearest_point</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                      <span class="n">query</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the closest point in `data` to `query`.</span>

<span class="sd">    :param data: reference array to locate &quot;on-data&quot; points within, shape (n_ref_points, d_dimensions)</span>
<span class="sd">    :param query: query array of &quot;off-data&quot; points, shape (n_query_points, d_dimensions)</span>
<span class="sd">    :return: array of the nearest point within `data` to each point in `query` shape (len(query), d_dimensions),</span>
<span class="sd">            array of the corresponding indices within the data array shape (len(query))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># calculate pairwise distance matrix, shape (n_query_points, n_ref_points)</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">XA</span><span class="o">=</span><span class="n">query</span><span class="p">,</span> <span class="n">XB</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># find the indices of the closest point within data to each query point by minimizing over the reference data axis</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">dists</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">ind</span></div>



<span class="c1">#################################################</span>
<span class="c1"># Helper functions for index array manipulation #</span>
<span class="c1">#################################################</span>


<div class="viewcode-block" id="convert_original_indices">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.convert_original_indices.html#tomodrgn.analysis.convert_original_indices">[docs]</a>
<span class="k">def</span> <span class="nf">convert_original_indices</span><span class="p">(</span><span class="n">ind_sel</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                             <span class="n">n_original</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                             <span class="n">ind_original_sel</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert selected indices relative to a filtered particle stack into indices relative to the unfiltered particle stack.</span>
<span class="sd">    Often useful when selecting a subset of indices when analyzing a model itself trained using `--ind` to filter the referenced particle stack.</span>

<span class="sd">    :param ind_sel: indices to keep from filtered particle stack</span>
<span class="sd">    :param n_original: the number of particles in the original unfiltered particle stack</span>
<span class="sd">    :param ind_original_sel: indices used to generate the filtered particle stack from the unfiltered particle stack</span>
<span class="sd">    :return: array of ind_sel indices re-indexed to be relative to the unfiltered particle stack</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sanity check inputs</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ind_sel</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ind_sel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_original</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;A selected index is out of range given the original unfiltered number of particles: </span><span class="si">{</span><span class="n">n_original</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">if</span> <span class="n">ind_original_sel</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ind_original_sel</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ind_original_sel</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_original</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;An index is out of range given the original unfiltered number of particles: </span><span class="si">{</span><span class="n">n_original</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ind_sel</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ind_original_sel</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;A selected index is out of range given the originally selected indices&#39;</span>

    <span class="c1"># calculate reindexed indices</span>
    <span class="n">unfiltered_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_original</span><span class="p">)</span>
    <span class="n">filtered_indices</span> <span class="o">=</span> <span class="n">unfiltered_indices</span><span class="p">[</span><span class="n">ind_original_sel</span><span class="p">]</span>
    <span class="n">sel_filtered_indices_reindexed</span> <span class="o">=</span> <span class="n">filtered_indices</span><span class="p">[</span><span class="n">ind_sel</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sel_filtered_indices_reindexed</span></div>



<div class="viewcode-block" id="combine_ind">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.combine_ind.html#tomodrgn.analysis.combine_ind">[docs]</a>
<span class="k">def</span> <span class="nf">combine_ind</span><span class="p">(</span><span class="n">selections_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                <span class="n">n_ind_total</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                <span class="n">kind</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;intersection&#39;</span><span class="p">,</span> <span class="s1">&#39;union&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;union&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine multiple indices selections by either intersection or union.</span>

<span class="sd">    :param selections_list: list of arrays of indices to combine</span>
<span class="sd">    :param n_ind_total: number of total indices (both selected and not selected)</span>
<span class="sd">    :param kind: type of combination selection to perform, one of &#39;intersection&#39;, &#39;union&#39;</span>
<span class="sd">    :return: array of combined and sorted selected indices, array of sorted unselected indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># combine indices</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">selections_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;intersection&#39;</span><span class="p">:</span>
        <span class="n">ind_selected</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="n">selections_list</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;union&#39;</span><span class="p">:</span>
        <span class="n">ind_selected</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">selections_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Ind combination kind not recognized: </span><span class="si">{</span><span class="n">kind</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># sort and convert to numpy arrays</span>
    <span class="n">ind_selected_not</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_ind_total</span><span class="p">))</span> <span class="o">-</span> <span class="n">ind_selected</span><span class="p">))</span>
    <span class="n">ind_selected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ind_selected</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ind_selected</span><span class="p">,</span> <span class="n">ind_selected_not</span></div>



<div class="viewcode-block" id="get_ind_for_cluster">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.get_ind_for_cluster.html#tomodrgn.analysis.get_ind_for_cluster">[docs]</a>
<span class="k">def</span> <span class="nf">get_ind_for_cluster</span><span class="p">(</span><span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                        <span class="n">selected_clusters</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the indices of particles belonging to the selected clusters.</span>

<span class="sd">    :param labels: array of cluster labels for each particle, shape (nptcls)</span>
<span class="sd">    :param selected_clusters: list of selected cluster labels</span>
<span class="sd">    :return: array of indices of particles belonging to the selected clusters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sanity check inputs</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">selected_cluster</span> <span class="ow">in</span> <span class="n">labels</span> <span class="k">for</span> <span class="n">selected_cluster</span> <span class="ow">in</span> <span class="n">selected_clusters</span><span class="p">])</span>

    <span class="c1"># get selected indices</span>
    <span class="n">ind_selected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ind</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">selected_clusters</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ind_selected</span></div>



<span class="c1">############</span>
<span class="c1"># Plotting #</span>
<span class="c1">############</span>


<div class="viewcode-block" id="get_colors_matplotlib">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.get_colors_matplotlib.html#tomodrgn.analysis.get_colors_matplotlib">[docs]</a>
<span class="k">def</span> <span class="nf">get_colors_matplotlib</span><span class="p">(</span><span class="n">num_colors</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                          <span class="n">cmap</span><span class="p">:</span> <span class="n">Colormap</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample num_colors colors from the specified color map as RGBA tuples</span>

<span class="sd">    :param num_colors: the number of colors to sample from the color map.</span>
<span class="sd">            If using a qualitative colormap such as `tab10`, the first `num_colors` are sampled sequentially.</span>
<span class="sd">            Otherwise, colors are sampled uniformly and sequentially from one pass over the entire colormap.</span>
<span class="sd">    :param cmap: the matplotlib colormap from which to sample colors. See: https://matplotlib.org/stable/users/explain/colors/colormaps.html#classes-of-colormaps</span>
<span class="sd">    :return: list of RGBA tuples for each color sampled from the color map.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the colormap object</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>

    <span class="c1"># if using a qualitative colormap, num_colors cannot exceed the cycle length without repeating colors</span>
    <span class="n">qualitative_cycle_lenths</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Pastel1&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
                                <span class="s1">&#39;Pastel2&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                                <span class="s1">&#39;Paired&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
                                <span class="s1">&#39;Accent&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                                <span class="s1">&#39;Dark2&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                                <span class="s1">&#39;Set1&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
                                <span class="s1">&#39;Set2&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                                <span class="s1">&#39;Set3&#39;</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
                                <span class="s1">&#39;tab10&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                                <span class="s1">&#39;tab20&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
                                <span class="s1">&#39;tab20b&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
                                <span class="s1">&#39;tab20c&#39;</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">cmap</span> <span class="ow">in</span> <span class="n">qualitative_cycle_lenths</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">cycle_length</span> <span class="o">=</span> <span class="n">qualitative_cycle_lenths</span><span class="p">[</span><span class="n">cmap</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">num_colors</span> <span class="o">&lt;=</span> <span class="n">cycle_length</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Too many colors requested (</span><span class="si">{</span><span class="n">num_colors</span><span class="si">}</span><span class="s1">) for qualitative colormap </span><span class="si">{</span><span class="n">cmap</span><span class="si">}</span><span class="s1"> with </span><span class="si">{</span><span class="n">cycle_length</span><span class="si">}</span><span class="s1"> colors available&#39;</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">cm</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">cycle_length</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_colors</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">cm</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">num_colors</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_colors</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">colors</span></div>



<div class="viewcode-block" id="get_colors_chimerax">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.get_colors_chimerax.html#tomodrgn.analysis.get_colors_chimerax">[docs]</a>
<span class="k">def</span> <span class="nf">get_colors_chimerax</span><span class="p">(</span><span class="n">num_colors</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample num_colors from the ChimeraX color scheme as RGBA tuples normalized [0,1].</span>

<span class="sd">    :param num_colors: the number of colors to sample from the color map.</span>
<span class="sd">            The first num_colors colors are sampled sequentially.</span>
<span class="sd">            If more colors are requested than exist in the ChimeraX color scheme, colors are repeated in order.</span>
<span class="sd">    :return: list of RGBA tuples for each color sampled from the color map.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chimerax_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(((</span><span class="mi">192</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">178</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">178</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">178</span><span class="p">,</span> <span class="mi">178</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">178</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">178</span><span class="p">,</span> <span class="mi">178</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">178</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">178</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">229</span><span class="p">,</span> <span class="mi">191</span><span class="p">,</span> <span class="mi">153</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">153</span><span class="p">,</span> <span class="mi">191</span><span class="p">,</span> <span class="mi">229</span><span class="p">,</span> <span class="mi">255</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">204</span><span class="p">,</span> <span class="mi">204</span><span class="p">,</span> <span class="mi">153</span><span class="p">,</span> <span class="mi">255</span><span class="p">)),</span> <span class="mi">255</span><span class="p">)</span>

    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">chimerax_colors</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">chimerax_colors</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_colors</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">colors</span></div>



<div class="viewcode-block" id="scatter_annotate">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.scatter_annotate.html#tomodrgn.analysis.scatter_annotate">[docs]</a>
<span class="k">def</span> <span class="nf">scatter_annotate</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">centers_xy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">centers_ind</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">annotate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="n">labels</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                     <span class="n">s</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a scatter plot with optional annotations for each cluster center and corresponding label.</span>

<span class="sd">    :param x: array of x coordinates to plot</span>
<span class="sd">    :param y: array of y coordinates to plot</span>
<span class="sd">    :param centers_xy: optionally an array of x,y coordinates of cluster centers to superimpose, shape (nclusters, 2). Mutually exclusive with specifying `centers_ind`.</span>
<span class="sd">    :param centers_ind: optionally an array indices indexing `x` and `y` as the cluster centers to superimpose, shape (nclusters). Mutually exclusive with specifying `centers_xy`.</span>
<span class="sd">    :param annotate: whether to annotate the plot with text labels corresponding to each cluster center</span>
<span class="sd">    :param labels: list of text labels for each cluster center</span>
<span class="sd">    :param alpha: transparency of scatter points, passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :param s: size of scatter points, passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :param kwargs: additional keyword arguments passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :return: matplotlib figure and axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create the base plot</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
               <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
               <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
               <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
               <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># plot cluster centers either by directly passed centers_xy, or by indexing into all data xy</span>
    <span class="k">if</span> <span class="n">centers_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">centers_xy</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">centers_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">[</span><span class="n">center_ind</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">center_ind</span><span class="p">]]</span> <span class="k">for</span> <span class="n">center_ind</span> <span class="ow">in</span> <span class="n">centers_ind</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">centers_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centers_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>

    <span class="c1"># add annotations for cluter center labels</span>
    <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">centers_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">))</span>

        <span class="c1"># use the adjustTexts library to tweak label placement for improved legibility</span>
        <span class="n">texts</span> <span class="o">=</span> <span class="p">[</span><span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                          <span class="n">y</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                          <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">),</span>
                          <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                          <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)]</span>
        <span class="n">adjust_text</span><span class="p">(</span><span class="n">texts</span><span class="o">=</span><span class="n">texts</span><span class="p">,</span>
                    <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">),</span>
                    <span class="n">time_lim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>



<div class="viewcode-block" id="scatter_annotate_hex">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.scatter_annotate_hex.html#tomodrgn.analysis.scatter_annotate_hex">[docs]</a>
<span class="k">def</span> <span class="nf">scatter_annotate_hex</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">centers_xy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">centers_ind</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">annotate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">labels</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sns</span><span class="o">.</span><span class="n">FacetGrid</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a hexbin plot with optional annotations for each cluster center and corresponding label.</span>

<span class="sd">    :param x: array of x coordinates to plot</span>
<span class="sd">    :param y: array of y coordinates to plot</span>
<span class="sd">    :param centers_xy: optionally an array of x,y coordinates of cluster centers to superimpose, shape (nclusters, 2). Mutually exclusive with specifying `centers_ind`.</span>
<span class="sd">    :param centers_ind: optionally an array indices indexing `x` and `y` as the cluster centers to superimpose, shape (nclusters). Mutually exclusive with specifying `centers_xy`.</span>
<span class="sd">    :param annotate: whether to annotate the plot with text labels corresponding to each cluster center</span>
<span class="sd">    :param labels: list of text labels for each cluster center</span>
<span class="sd">    :param kwargs: additional keyword arguments passed to seaborn.jointplot</span>
<span class="sd">    :return: matplotlib figure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create the base plot</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">jointplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
                      <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                      <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;hex&#39;</span><span class="p">,</span>
                      <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># plot cluster centers either by directly passed centers_xy, or by indexing into all data xy</span>
    <span class="k">if</span> <span class="n">centers_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">centers_xy</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">centers_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">[</span><span class="n">center_ind</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">center_ind</span><span class="p">]]</span> <span class="k">for</span> <span class="n">center_ind</span> <span class="ow">in</span> <span class="n">centers_ind</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">centers_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">g</span><span class="o">.</span><span class="n">ax_joint</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centers_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>

    <span class="c1"># add annotations for cluter center labels</span>
    <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">centers_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">))</span>

        <span class="c1"># use the adjustTexts library to tweak label placement for improved legibility</span>
        <span class="n">texts</span> <span class="o">=</span> <span class="p">[</span><span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                          <span class="n">y</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                          <span class="n">s</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">),</span>
                          <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                          <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)]</span>
        <span class="n">adjust_text</span><span class="p">(</span><span class="n">texts</span><span class="o">=</span><span class="n">texts</span><span class="p">,</span>
                    <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">),</span>
                    <span class="n">time_lim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span></div>



<div class="viewcode-block" id="scatter_color">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.scatter_color.html#tomodrgn.analysis.scatter_color">[docs]</a>
<span class="k">def</span> <span class="nf">scatter_color</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">c</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                  <span class="n">cmap</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span><span class="p">,</span>
                  <span class="n">s</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                  <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                  <span class="n">cbar_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a scatter plot colored by auto-mapped values of `c` according to specified `cmap`, and plot a corresponding colorbar.</span>

<span class="sd">    :param x: array of x coordinates to plot</span>
<span class="sd">    :param y: array of y coordinates to plot</span>
<span class="sd">    :param c: array of values by which to map color of each xy point</span>
<span class="sd">    :param cmap: the matplotlib colormap from which to sample colors. See: https://matplotlib.org/stable/users/explain/colors/colormaps.html#classes-of-colormaps</span>
<span class="sd">    :param s: size of scatter points, passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :param alpha: transparency of scatter points, passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :param cbar_label: optional text to label the colorbar</span>
<span class="sd">    :param kwargs: additional keyword arguments passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :return: matplotlib figure and axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sanity check inputs</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="c1"># draw base plot</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">sc</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
                    <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># add the colorbar</span>
    <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
    <span class="n">cbar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">draw_without_rendering</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">cbar_label</span><span class="p">:</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">cbar_label</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>



<div class="viewcode-block" id="plot_by_cluster">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.plot_by_cluster.html#tomodrgn.analysis.plot_by_cluster">[docs]</a>
<span class="k">def</span> <span class="nf">plot_by_cluster</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                    <span class="n">labels_sel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                    <span class="n">centers_xy</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">centers_ind</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">annotate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">s</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                    <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot all points `x,y` with colors per class `labels`, with optional annotations for each cluster center and corresponding label.</span>

<span class="sd">    :param x: array of x coordinates to plot, shape (nptcls)</span>
<span class="sd">    :param y: array of y coordinates to plot, shape (nptcls)</span>
<span class="sd">    :param labels: array of cluster labels for each particle, shape (nptcls)</span>
<span class="sd">    :param labels_sel: selected cluster labels to plot.</span>
<span class="sd">            If int, plot all classes matching label in `range(labels_sel)`.</span>
<span class="sd">            If array of int, plot all classes matching label in `labels_sel`.</span>
<span class="sd">    :param centers_xy: optionally an array of x,y coordinates of cluster centers to superimpose, shape (n_labels_sel, 2). Mutually exclusive with specifying `centers_ind`.</span>
<span class="sd">    :param centers_ind: optionally an array indices indexing `x` and `y` as the cluster centers to superimpose, shape (n_labels_sel). Mutually exclusive with specifying `centers_xy`.</span>
<span class="sd">    :param annotate: whether to annotate the plot with text labels corresponding to each cluster center</span>
<span class="sd">    :param s: size of scatter points, passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :param alpha: transparency of scatter points, passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :param cmap: the matplotlib colormap from which to sample colors. See: https://matplotlib.org/stable/users/explain/colors/colormaps.html#classes-of-colormaps</span>
<span class="sd">    :param kwargs: additional keyword arguments passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :return: matplotlib figure and axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create the base plot</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

    <span class="c1"># get colors for clusters by sampling cmap</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">labels_sel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">))</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">get_colors_matplotlib</span><span class="p">(</span><span class="n">num_colors</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">),</span>
                                   <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>

    <span class="c1"># scatter by cluster</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label_sel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">):</span>
        <span class="n">label_inds</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">label_sel</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">label_inds</span><span class="p">],</span>
                   <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">[</span><span class="n">label_inds</span><span class="p">],</span>
                   <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                   <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                   <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;k</span><span class="si">{</span><span class="n">label_sel</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                   <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                   <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># plot cluster centers</span>
    <span class="k">if</span> <span class="n">centers_ind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">centers_xy</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">centers_xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">[</span><span class="n">center_ind</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">center_ind</span><span class="p">]]</span> <span class="k">for</span> <span class="n">center_ind</span> <span class="ow">in</span> <span class="n">centers_ind</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">centers_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">centers_xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>

    <span class="c1"># add annotations for cluter center labels</span>
    <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">centers_xy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># use the adjustTexts library to tweak label placement for improved legibility</span>
        <span class="n">texts</span> <span class="o">=</span> <span class="p">[</span><span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
                          <span class="n">y</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">centers_xy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
                          <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;cluster </span><span class="si">{</span><span class="n">label_sel</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                          <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                          <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
                 <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label_sel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">)]</span>
        <span class="n">adjust_text</span><span class="p">(</span><span class="n">texts</span><span class="o">=</span><span class="n">texts</span><span class="p">,</span>
                    <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">),</span>
                    <span class="n">time_lim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>



<div class="viewcode-block" id="plot_by_cluster_subplot">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.plot_by_cluster_subplot.html#tomodrgn.analysis.plot_by_cluster_subplot">[docs]</a>
<span class="k">def</span> <span class="nf">plot_by_cluster_subplot</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">labels_sel</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                            <span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">s</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                            <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
                            <span class="n">cmap</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot all points `x,y` with colors per class `labels` on individual subplots for each of `labels_sel`.</span>

<span class="sd">    :param x: array of x coordinates to plot, shape (nptcls)</span>
<span class="sd">    :param y: array of y coordinates to plot, shape (nptcls)</span>
<span class="sd">    :param labels: array of cluster labels for each particle, shape (nptcls)</span>
<span class="sd">    :param labels_sel: selected cluster labels to plot.</span>
<span class="sd">            If int, plot all classes matching label in `range(labels_sel)`.</span>
<span class="sd">            If array of int, plot all classes matching label in `labels_sel`.</span>
<span class="sd">    :param s: size of scatter points, passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :param alpha: transparency of scatter points, passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :param cmap: the matplotlib colormap from which to sample colors. See: https://matplotlib.org/stable/users/explain/colors/colormaps.html#classes-of-colormaps</span>
<span class="sd">    :param kwargs: additional keyword arguments passed to matplotlib.pyplot.scatter</span>
<span class="sd">    :return: matplotlib figure and axes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get colors for clusters by sampling cmap</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">labels_sel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">))</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">get_colors_matplotlib</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">),</span> <span class="n">cmap</span><span class="p">)</span>

    <span class="c1"># create base plot</span>
    <span class="n">ncol</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">)</span> <span class="o">**</span> <span class="mf">.5</span><span class="p">))</span>
    <span class="n">nrow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">)</span> <span class="o">/</span> <span class="n">ncol</span><span class="p">))</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="n">ncol</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ncol</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nrow</span><span class="p">))</span>

    <span class="c1"># draw subplots</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label_inds</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">labels_sel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">label_inds</span><span class="p">],</span>
                       <span class="n">y</span><span class="p">[</span><span class="n">label_inds</span><span class="p">],</span>
                       <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                       <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">labels_sel</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span></div>



<div class="viewcode-block" id="plot_euler">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.plot_euler.html#tomodrgn.analysis.plot_euler">[docs]</a>
<span class="k">def</span> <span class="nf">plot_euler</span><span class="p">(</span><span class="n">theta</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">phi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
               <span class="n">psi</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the distribution of Euler angles as a hexbin of `theta` and `phi`, and a histogram of `psi`.</span>

<span class="sd">    :param theta: array of euler angles `theta`, shape (nimgs)</span>
<span class="sd">    :param phi: array of euler angles `phi`, shape (nimgs)</span>
<span class="sd">    :param psi: array of euler angles `psi`, shape (nimgs)</span>
<span class="sd">    :return: matplotlib hexbin figure of theta vs phi, matplotlib figure and axes of psi histogram</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># create base plot for theta and phi as jointplot</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">jointplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
                      <span class="n">y</span><span class="o">=</span><span class="n">phi</span><span class="p">,</span>
                      <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;hex&#39;</span><span class="p">,</span>
                      <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span> <span class="mi">180</span><span class="p">),</span>
                      <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">180</span><span class="p">),</span>
                      <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">set_axis_labels</span><span class="p">(</span><span class="s2">&quot;theta&quot;</span><span class="p">,</span> <span class="s2">&quot;phi&quot;</span><span class="p">)</span>

    <span class="c1"># create second plot for psi as histogram</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;psi&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>



<div class="viewcode-block" id="plot_translations">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.plot_translations.html#tomodrgn.analysis.plot_translations">[docs]</a>
<span class="k">def</span> <span class="nf">plot_translations</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the distribution of shifts in x-axis vs shifts in y-axis (units: px)</span>

<span class="sd">    :param trans: translations in x and y, shape (nimgs, 2)</span>
<span class="sd">    :return: matplotlib hexbin figure of tx vs ty, axes of hexbin</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set near-zero translations to 0.0 to allow sns.jointplot to work</span>
    <span class="n">trans</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">jointplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">trans</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="n">y</span><span class="o">=</span><span class="n">trans</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                      <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;hex&#39;</span><span class="p">,</span>
                      <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">set_axis_labels</span><span class="p">(</span><span class="s1">&#39;tx (px)&#39;</span><span class="p">,</span> <span class="s1">&#39;ty (px)&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">g</span></div>



<div class="viewcode-block" id="plot_losses">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.plot_losses.html#tomodrgn.analysis.plot_losses">[docs]</a>
<span class="k">def</span> <span class="nf">plot_losses</span><span class="p">(</span><span class="n">runlog</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the total loss, reconstruction loss, and KLD divergence per epoch.</span>

<span class="sd">    :param runlog: the run.log auto-generated by tomodrgn train_vae</span>
<span class="sd">    :return: matplotlib figure and axes of line plots for each loss</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">losses</span> <span class="o">=</span> <span class="n">parse_all_losses</span><span class="p">(</span><span class="n">runlog</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;reconstruction loss&#39;</span><span class="p">,</span> <span class="s1">&#39;latent loss&#39;</span><span class="p">,</span> <span class="s1">&#39;total loss&#39;</span><span class="p">]</span>

    <span class="n">n_rows</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">n_cols</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">n_cols</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n_rows</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">losses</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;epoch&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span></div>



<div class="viewcode-block" id="plot_projections">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.plot_projections.html#tomodrgn.analysis.plot_projections">[docs]</a>
<span class="k">def</span> <span class="nf">plot_projections</span><span class="p">(</span><span class="n">images</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">labels</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                     <span class="n">width_between_imgs_px</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
                     <span class="n">height_between_imgs_px</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot a stack of grayscale images.</span>
<span class="sd">    The rendered figure has precisely the correct number of pixels for each image, avoiding the default resampling behavior of `plt.imshow`.</span>

<span class="sd">    :param images: array of images to plot, shape (nimgs, boxsize, boxsize)</span>
<span class="sd">    :param labels: list of text labels to annotate the title of each image, len(nimgs)</span>
<span class="sd">    :param width_between_imgs_px:</span>
<span class="sd">    :param height_between_imgs_px:</span>
<span class="sd">    :return: matplotlib figure and axes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># derive dimensions of each image</span>
    <span class="n">width_one_img_px</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">height_one_img_px</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># derive number of rows and columns</span>
    <span class="n">ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">**</span> <span class="mf">.5</span><span class="p">))</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">/</span> <span class="n">ncols</span><span class="p">))</span>

    <span class="c1"># derive overall figure dimensions</span>
    <span class="n">figwidth_px</span> <span class="o">=</span> <span class="p">(</span><span class="n">width_one_img_px</span> <span class="o">*</span> <span class="n">ncols</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">width_between_imgs_px</span> <span class="o">*</span> <span class="p">(</span><span class="n">ncols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">figheight_px</span> <span class="o">=</span> <span class="p">(</span><span class="n">height_one_img_px</span> <span class="o">+</span> <span class="n">height_between_imgs_px</span><span class="p">)</span> <span class="o">*</span> <span class="n">nrows</span>
    <span class="n">figwidth_inches</span> <span class="o">=</span> <span class="n">figwidth_px</span> <span class="o">/</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;figure.dpi&#39;</span><span class="p">]</span>
    <span class="n">figheight_inches</span> <span class="o">=</span> <span class="n">figheight_px</span> <span class="o">/</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;figure.dpi&#39;</span><span class="p">]</span>

    <span class="c1"># create figure and associated gridspec to lay out images</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">figwidth_inches</span><span class="p">,</span> <span class="n">figheight_inches</span><span class="p">))</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="n">gridspec</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">,</span>
                           <span class="n">ncols</span><span class="o">=</span><span class="n">ncols</span><span class="p">,</span>
                           <span class="n">figure</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span>
                           <span class="n">top</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">bottom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">wspace</span><span class="o">=</span><span class="n">width_between_imgs_px</span> <span class="o">/</span> <span class="n">width_one_img_px</span><span class="p">,</span>
                           <span class="n">hspace</span><span class="o">=</span><span class="n">height_between_imgs_px</span> <span class="o">/</span> <span class="p">(</span><span class="n">height_one_img_px</span> <span class="o">*</span> <span class="n">nrows</span><span class="p">))</span>

    <span class="c1"># plot images</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span> <span class="o">*</span> <span class="n">ncols</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">interpolation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">images</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_label_count_distribution">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.plot_label_count_distribution.html#tomodrgn.analysis.plot_label_count_distribution">[docs]</a>
<span class="k">def</span> <span class="nf">plot_label_count_distribution</span><span class="p">(</span><span class="n">ptcl_star</span><span class="p">:</span> <span class="n">starfile</span><span class="o">.</span><span class="n">TiltSeriesStarfile</span> <span class="o">|</span> <span class="n">starfile</span><span class="o">.</span><span class="n">TomoParticlesStarfile</span><span class="p">,</span>
                                  <span class="n">class_labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot the distribution of class labels per tomogram or micrograph as a heatmap.</span>

<span class="sd">    :param ptcl_star: image series star file describing the same number of particles as class_labels</span>
<span class="sd">    :param class_labels: array of class labels, shape (nptcls, 1)</span>
<span class="sd">    :return: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get a df with one row corresponding to each particle</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ptcl_star</span><span class="p">)</span> <span class="ow">is</span> <span class="n">starfile</span><span class="o">.</span><span class="n">TiltSeriesStarfile</span><span class="p">:</span>
        <span class="n">df_first_img</span> <span class="o">=</span> <span class="n">ptcl_star</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">ptcl_star</span><span class="o">.</span><span class="n">header_ptcl_uid</span><span class="p">,</span> <span class="n">as_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">ptcl_star</span><span class="p">)</span> <span class="ow">is</span> <span class="n">starfile</span><span class="o">.</span><span class="n">TomoParticlesStarfile</span><span class="p">:</span>
        <span class="n">df_first_img</span> <span class="o">=</span> <span class="n">ptcl_star</span><span class="o">.</span><span class="n">df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Type of passed star file not recognized: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ptcl_star</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># group particles by source tomogram</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">tomogram_name_col</span> <span class="o">=</span> <span class="n">ptcl_star</span><span class="o">.</span><span class="n">header_ptcl_micrograph</span> <span class="k">if</span> <span class="n">ptcl_star</span><span class="o">.</span><span class="n">header_ptcl_micrograph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ptcl_star</span><span class="o">.</span><span class="n">header_ptcl_tomogram</span>
        <span class="n">ind_ptcls_per_tomo</span> <span class="o">=</span> <span class="p">[</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">df_first_img</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">tomogram_name_col</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1"># for some reason, header_ptcl_micrograph nor header_ptcl_tomogram not found in df.columns</span>
        <span class="c1"># falling back to trying to split header_ptcl_uid on `_` and taking 0th value as stand-in for tomogram ID, following Warp convention of `XXX_YYYYY`</span>
        <span class="n">df_first_img</span><span class="p">[[</span><span class="s1">&#39;_tempTomogramUID&#39;</span><span class="p">,</span> <span class="s1">&#39;_tempParticleUID&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df_first_img</span><span class="p">[</span><span class="n">ptcl_star</span><span class="o">.</span><span class="n">header_ptcl_uid</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ind_ptcls_per_tomo</span> <span class="o">=</span> <span class="p">[</span><span class="n">group</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">group_name</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">df_first_img</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;_tempTomogramUID&#39;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>

    <span class="n">label_distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_ptcls_per_tomo</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">class_labels</span><span class="p">))))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind_one_tomo</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ind_ptcls_per_tomo</span><span class="p">):</span>
        <span class="c1"># don&#39;t use np.unique directly on one tomogram in case that tomogram has zero particles in given class</span>
        <span class="n">counts_one_tomo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="n">ind_ptcls_per_tomo</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">class_labels</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">)])</span>
        <span class="n">label_distribution</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts_one_tomo</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind_ptcls_per_tomo</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">class_labels</span><span class="p">))</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">),</span>
                           <span class="n">layout</span><span class="o">=</span><span class="s1">&#39;compressed&#39;</span><span class="p">)</span>

    <span class="n">distribution_plot</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">label_distribution</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">distribution_plot</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;particle count&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;tomogram UID&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;class label&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="plot_three_column_correlation">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.plot_three_column_correlation.html#tomodrgn.analysis.plot_three_column_correlation">[docs]</a>
<span class="k">def</span> <span class="nf">plot_three_column_correlation</span><span class="p">(</span><span class="n">reference_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                  <span class="n">query_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                  <span class="n">reference_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                                  <span class="n">query_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot two reference vectors (e.g. l-UMAP1 and l-UMAP2) for potential correlation with a third query vector (e.g. CoordinateX, DefocusU, etc.).</span>

<span class="sd">    Produces a figure with 1 row and 3 columns of subplots:</span>

<span class="sd">    #. hexbin of reference vector 1 vs query vector.</span>
<span class="sd">    #. hexbin of reference vector 2 vs query vector.</span>
<span class="sd">    #. scatter of reference vector 1 vs reference vector 2 colored by query vector.</span>

<span class="sd">    :param reference_array: array of reference vector values, shape (nptcls, 2)</span>
<span class="sd">    :param query_array: array of query vector values, shape (nptcls, 1)</span>
<span class="sd">    :param reference_names: list naming each reference vector</span>
<span class="sd">    :param query_name: name of query vector</span>
<span class="sd">    :return: None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax0</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">))</span>

    <span class="n">ax0</span><span class="o">.</span><span class="n">hexbin</span><span class="p">(</span><span class="n">reference_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">query_array</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ax0</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">reference_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ax0</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">query_name</span><span class="p">)</span>

    <span class="n">ax1</span><span class="o">.</span><span class="n">hexbin</span><span class="p">(</span><span class="n">reference_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">query_array</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">reference_names</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">query_name</span><span class="p">)</span>

    <span class="n">scatter1</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">reference_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">reference_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">query_array</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rasterized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">query_name</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">reference_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">reference_names</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>



<div class="viewcode-block" id="ipy_plot_interactive">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.ipy_plot_interactive.html#tomodrgn.analysis.ipy_plot_interactive">[docs]</a>
<span class="k">def</span> <span class="nf">ipy_plot_interactive</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Box</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create and display an interactive plotly scatter plot and associated ipywidgets custom widgets, allowing exploration of numeric columns of a pandas dataframe.</span>
<span class="sd">    * The scatter plot plots the selected dataframe columns with optional colormapping based on a third dataframe column. Hovertext indicates the hovered particle&#39;s row index in the input dataframe.</span>
<span class="sd">    * The widget at bottom left allows control of the scatter plot: column selections for x, y, and colormap; which plotly colormap to use; marker size and opacity.</span>
<span class="sd">    * A custom selection can be made through a lasso selection tool on the scatter plot. The row index of selected points in the input dataframe is displayed in the table at bottom center.</span>
<span class="sd">    * The widget at bottom right allows lasso-selected points to be saved as a numpy array of df row indices stored in a timestamped `pkl` file.</span>

<span class="sd">    Sample usage:</span>
<span class="sd">        `ipy_plot_interactive(df)`</span>

<span class="sd">    :param df: pandas dataframe to interactively plot, colormap, and select points from.</span>
<span class="sd">    :return: ipywidgets.Box containing the interactive figure and widgets</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">initialize_scatterplot</span><span class="p">(</span><span class="n">_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">go</span><span class="o">.</span><span class="n">FigureWidget</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the plotly FigureWidget containing the scatter plot drawn with OpenGL backend for performance &gt; 10k points.</span>

<span class="sd">        :param _df: pandas dataframe to interactively plot</span>
<span class="sd">        :return: plotly FigureWidget containing scatter plot (lacking controls for interactive plotting)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis</span> <span class="o">=</span> <span class="n">_df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">_fig1</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">FigureWidget</span><span class="p">([</span><span class="n">go</span><span class="o">.</span><span class="n">Scattergl</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">_df</span><span class="p">[</span><span class="n">xaxis</span><span class="p">],</span>
                                              <span class="n">y</span><span class="o">=</span><span class="n">_df</span><span class="p">[</span><span class="n">yaxis</span><span class="p">],</span>
                                              <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span>
                                              <span class="n">text</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_df</span><span class="o">.</span><span class="n">index</span><span class="p">],</span>
                                              <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                                          <span class="n">opacity</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
                                              <span class="p">)],</span>
                                <span class="n">layout_margin</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
        <span class="n">_fig1</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">xaxis_title</span><span class="o">=</span><span class="n">xaxis</span><span class="p">,</span> <span class="n">yaxis_title</span><span class="o">=</span><span class="n">yaxis</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
        <span class="n">_fig1</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">dragmode</span> <span class="o">=</span> <span class="s1">&#39;lasso&#39;</span>
        <span class="k">return</span> <span class="n">_fig1</span>

    <span class="k">def</span> <span class="nf">initialize_table</span><span class="p">(</span><span class="n">_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">go</span><span class="o">.</span><span class="n">FigureWidget</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the plotly FigureWidget containing the Table of scatter point row indices from the input dataframe.</span>

<span class="sd">        :param _df: pandas dataframe to draw scatter point row indices from.</span>
<span class="sd">        :return: plotly FigureWidget containing table (lacking controls for saving indices)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_fig2</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">FigureWidget</span><span class="p">([</span><span class="n">go</span><span class="o">.</span><span class="n">Table</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;selected indices&#39;</span><span class="p">]),</span>
                                          <span class="n">cells</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="p">[</span><span class="n">_df</span><span class="o">.</span><span class="n">index</span><span class="p">]))],</span>
                                <span class="n">layout_margin</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="mi">50</span><span class="p">))</span>
        <span class="n">_fig2</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">height</span><span class="o">=</span><span class="mi">250</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_fig2</span>

    <span class="k">def</span> <span class="nf">update_scatterplot</span><span class="p">(</span><span class="n">xaxis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">yaxis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">color_by</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">colorscale</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">size</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                           <span class="n">opacity</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback to update the `fig1` scatter plot.</span>

<span class="sd">        :param xaxis: the column from the dataframe to plot as x-axis values</span>
<span class="sd">        :param yaxis: the column from the dataframe to plot as y-axis values</span>
<span class="sd">        :param color_by: the column from the dataframe to use for color mapping</span>
<span class="sd">        :param colorscale: a named colormap recognized by plotly to map `color_by` values</span>
<span class="sd">        :param size: size of scatter point markers</span>
<span class="sd">        :param opacity: opacity of scatter point markers</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scatter</span> <span class="o">=</span> <span class="n">fig1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">fig1</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">scatter</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">xaxis</span><span class="p">]</span>
            <span class="n">scatter</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">yaxis</span><span class="p">]</span>
            <span class="n">scatter</span><span class="o">.</span><span class="n">marker</span><span class="o">.</span><span class="n">colorscale</span> <span class="o">=</span> <span class="n">colorscale</span>
            <span class="k">if</span> <span class="n">colorscale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">scatter</span><span class="o">.</span><span class="n">marker</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scatter</span><span class="o">.</span><span class="n">marker</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">color_by</span><span class="p">]</span> <span class="k">if</span> <span class="n">color_by</span> <span class="o">!=</span> <span class="s1">&#39;index&#39;</span> <span class="k">else</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
            <span class="n">scatter</span><span class="o">.</span><span class="n">marker</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
            <span class="n">scatter</span><span class="o">.</span><span class="n">marker</span><span class="o">.</span><span class="n">opacity</span> <span class="o">=</span> <span class="n">opacity</span>
            <span class="n">fig1</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">xaxis</span>
            <span class="n">fig1</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">yaxis</span>

    <span class="k">def</span> <span class="nf">update_table</span><span class="p">(</span><span class="n">trace</span><span class="p">:</span> <span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">,</span>
                     <span class="n">points</span><span class="p">:</span> <span class="n">plotly</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">Points</span><span class="p">,</span>
                     <span class="n">selector</span><span class="p">:</span> <span class="n">plotly</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">LassoSelector</span> <span class="o">|</span> <span class="n">plotly</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">BoxSelector</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback to update the `fig2` table of selected indices based on the current Lasso or Box selection of points in `fig1` scatter plot.</span>

<span class="sd">        :param trace: the plotly trace that this callback is called from, mandatory parameter in signature but not explicitly used</span>
<span class="sd">        :param points: the selected points associated with the active selection</span>
<span class="sd">        :param selector: the selector associated with the trace that this callback is called from, mandatory parameter in signature but not explicitly used</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take all three parameters for the callback to function, but we do not currently use either trace or selector</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">trace</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">selector</span>

        <span class="k">with</span> <span class="n">fig2</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">point_inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if no points are selected, interpret this as resetting the selection so populate the table with all indices</span>
                <span class="n">fig2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># populate the table with indices of selected points</span>
                <span class="n">fig2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">points</span><span class="o">.</span><span class="n">point_inds</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">save_indices_pkl_callback</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Button</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback to save the currently selected indices in `fig2` table as a sorted and non-redundant numpy array to a pickle file.</span>

<span class="sd">        :param b: the clicked button widget calling this callback</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">b</span>

        <span class="c1"># define the output pickle file contents</span>
        <span class="n">inds_selected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fig2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>

        <span class="c1"># define the output pickle file name</span>
        <span class="n">cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="n">current_datetime</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">-%H-%M-%S&#39;</span><span class="p">)</span>
        <span class="n">selection_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inds_selected</span><span class="p">)</span>
        <span class="n">out_path_inds</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cwd</span><span class="si">}</span><span class="s1">/selected_indices_</span><span class="si">{</span><span class="n">current_datetime</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">selection_count</span><span class="si">}</span><span class="s1">-particles.pkl&#39;</span>

        <span class="c1"># save the indices pickle</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">save_pkl</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">inds_selected</span><span class="p">,</span> <span class="n">out_pkl</span><span class="o">=</span><span class="n">out_path_inds</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">log_output</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Saved </span><span class="si">{</span><span class="n">out_path_inds</span><span class="si">}</span><span class="s1"> </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clear_output_callback</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Button</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback to clear text output in the Output widget.</span>

<span class="sd">        :param b: the clicked button widget calling this callback</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">b</span>

        <span class="c1"># clear the text output</span>
        <span class="n">log_output</span><span class="o">.</span><span class="n">clear_output</span><span class="p">()</span>

    <span class="c1"># create figure and table</span>
    <span class="n">fig1</span> <span class="o">=</span> <span class="n">initialize_scatterplot</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
    <span class="n">fig2</span> <span class="o">=</span> <span class="n">initialize_table</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    <span class="c1"># create widget and define interactivity for scatter plot adjustment</span>
    <span class="n">scatter_display_widget</span> <span class="o">=</span> <span class="n">interactive</span><span class="p">(</span><span class="n">update_scatterplot</span><span class="p">,</span>
                                         <span class="n">xaxis</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                         <span class="n">yaxis</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">select_dtypes</span><span class="p">(</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                         <span class="n">color_by</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                         <span class="n">colorscale</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span><span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">plotly</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">named_colorscales</span><span class="p">(),</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
                                         <span class="n">size</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">FloatSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">continuous_update</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                         <span class="n">opacity</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">FloatSlider</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">continuous_update</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

    <span class="c1"># create widgets and define interactivity for saving indices, logging output, and clearing logged output</span>
    <span class="n">save_inds_button</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;save selected indices&#39;</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">))</span>
    <span class="n">clear_output_button</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;clear log output&#39;</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">))</span>
    <span class="n">log_output</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Output</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">border</span><span class="o">=</span><span class="s1">&#39;1px solid black&#39;</span><span class="p">,</span> <span class="n">overflow</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="s1">&#39;200px&#39;</span><span class="p">))</span>
    <span class="n">save_inds_button</span><span class="o">.</span><span class="n">on_click</span><span class="p">(</span><span class="n">save_indices_pkl_callback</span><span class="p">)</span>
    <span class="n">clear_output_button</span><span class="o">.</span><span class="n">on_click</span><span class="p">(</span><span class="n">clear_output_callback</span><span class="p">)</span>

    <span class="c1"># define interactivity for updating table with lasso or box selection</span>
    <span class="n">fig1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">on_selection</span><span class="p">(</span><span class="n">update_table</span><span class="p">)</span>

    <span class="c1"># arrange layout of figure, table, and widget objects</span>
    <span class="n">controls_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">([</span><span class="n">save_inds_button</span><span class="p">,</span> <span class="n">clear_output_button</span><span class="p">]),</span>
                                             <span class="n">log_output</span><span class="p">],</span>
                                   <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;40%&#39;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="s1">&#39;inline-flex&#39;</span><span class="p">))</span>
    <span class="n">container</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">([</span><span class="n">fig1</span><span class="p">,</span>
                              <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">scatter_display_widget</span><span class="p">,</span> <span class="n">fig2</span><span class="p">,</span> <span class="n">controls_widget</span><span class="p">],</span>
                                           <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;100%&#39;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="s1">&#39;inline-flex&#39;</span><span class="p">))])</span>

    <span class="c1"># print some helpful instructions</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Welcome to the interactive dataframe explorer!&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  1. Scatter plot settings are in the bottom left corner of the widget.&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  2. Hover over a point in the scatter plot to see its current (x,y) coordinate and its row index in the input dataframe.&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  3. Left click and drag on the scatter plot to draw an interactive lasso selection.&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  4. Create a lasso selection around no points and then double left click on the plot to reset the selection&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  5. Click &quot;save selected indices&quot; in the bottom right corner of the widget to save an indices.pkl file to the current working directory.&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  6. Hover over the scatter plot and select &quot;Download plot as a png&quot; to save a snapshot of the plot including lasso selection definition.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">container</span></div>



<div class="viewcode-block" id="load_dataframe">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.load_dataframe.html#tomodrgn.analysis.load_dataframe">[docs]</a>
<span class="k">def</span> <span class="nf">load_dataframe</span><span class="p">(</span><span class="o">*</span><span class="p">,</span>
                   <span class="n">z</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">pc</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">tsne_emb</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">umap_emb</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">euler</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">trans</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">labels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge known types of numpy arrays into a single pandas dataframe for downstream analysis.</span>
<span class="sd">    Only supplied key word arguments will be added as columns to the dataframe.</span>

<span class="sd">    :param z: array of latent embeddings, shape (nptcls, zdim)</span>
<span class="sd">    :param pc: array of PCA-transformed latent embeddings, shape (nptcls, PC-dim)</span>
<span class="sd">    :param tsne_emb: array of t-SNE-transformed latent embeddings, shape (nptcls, tSNE-dim)</span>
<span class="sd">    :param umap_emb: array of UMAP-transformed latent embeddings, shape (nptcls, UMAP-dim)</span>
<span class="sd">    :param euler: array of Euler angles, shape (nptcls, 3)</span>
<span class="sd">    :param trans: array of translation vectors, shape (nptcls, 2)</span>
<span class="sd">    :param labels: array of labels, shape (nptcls, )</span>
<span class="sd">    :param kwargs: key:value pairs of additional column_name: numpy array of values to add as additional columns to the dataframe</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># add supplied parameter arrays to a dictionary</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">umap_emb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;l-UMAP1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">umap_emb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;l-UMAP2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">umap_emb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">tsne_emb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;l-TSNE1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tsne_emb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;l-TSNE2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tsne_emb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">pc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zdim</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">zdim</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;l-PC</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;labels&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>
    <span class="k">if</span> <span class="n">euler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;theta&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">euler</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">euler</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;psi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">euler</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;tx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ty&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zdim</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">zdim</span><span class="p">):</span>
            <span class="n">data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;z</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">kk</span><span class="p">,</span> <span class="n">vv</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">data</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">vv</span>

    <span class="c1"># assert all items have the same length</span>
    <span class="n">array_lengths</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">array_lengths</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Not all supplied arrays have the same length: </span><span class="si">{</span><span class="n">array_lengths</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="c1"># create a dataframe from the formatted dictionary</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>

    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="recursive_load_dataframe">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.recursive_load_dataframe.html#tomodrgn.analysis.recursive_load_dataframe">[docs]</a>
<span class="k">def</span> <span class="nf">recursive_load_dataframe</span><span class="p">(</span><span class="n">volumeseries_star_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                             <span class="n">tomo_id_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create merged dataframe containing:</span>

<span class="sd">    #. imageseries star file used to train model (referenced in train_vae ``config.pkl``)</span>
<span class="sd">    #. volumeseries star file specified here</span>
<span class="sd">    #. any ``*.pkl`` file found recursively within this notebook&#39;s directory which contains a numpy array with first axis shape matching the number of particles in the imageseries star file.</span>

<span class="sd">    Data are added assuming all indexing matches imageseries star file particle order.</span>

<span class="sd">    :param volumeseries_star_path: absolute path to volume series star file, must reference the same set of particles referenced by the starfile used for tomodrgn train_vae</span>
<span class="sd">    :param tomo_id_column: full string name of column containing unique values per tomogram in volseries star file</span>
<span class="sd">    :return: pandas dataframe containing all described data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the epoch being analyzed from cwd (assumed format: analyze.N)</span>
    <span class="n">cwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="n">epoch</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">cwd</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># load the config of train_vae assumed to be 1 directory above</span>
    <span class="n">cfg</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_pkl</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cwd</span><span class="si">}</span><span class="s1">/../config.pkl&#39;</span><span class="p">)</span>

    <span class="c1"># load the imageseries filtered star file referenced in config from training, keeping 1st image dose-ascending per particle</span>
    <span class="n">ptcls_star</span> <span class="o">=</span> <span class="n">starfile</span><span class="o">.</span><span class="n">TiltSeriesStarfile</span><span class="p">(</span><span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;starfile_args&#39;</span><span class="p">][</span><span class="s1">&#39;sourcefile_filtered&#39;</span><span class="p">])</span>
    <span class="n">ptcls_star</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">sort_ptcl_imgs</span><span class="o">=</span><span class="s1">&#39;dose_ascending&#39;</span><span class="p">,</span> <span class="n">use_first_ntilts</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># create standalone dataframe for all data to be added</span>
    <span class="n">df_merged</span> <span class="o">=</span> <span class="n">ptcls_star</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># calculate the number of particles referenced in imageseries star file</span>
    <span class="n">ptcl_img_inds</span> <span class="o">=</span> <span class="n">ptcls_star</span><span class="o">.</span><span class="n">get_ptcl_img_indices</span><span class="p">()</span>
    <span class="n">n_ptcls</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ptcl_img_inds</span><span class="p">)</span>

    <span class="c1"># load volumeseries star</span>
    <span class="n">vols_star</span> <span class="o">=</span> <span class="n">starfile</span><span class="o">.</span><span class="n">GenericStarfile</span><span class="p">(</span><span class="n">volumeseries_star_path</span><span class="p">)</span>

    <span class="c1"># filter volumeseries star by imageseries star filtered particle indices</span>
    <span class="n">vols_star_ptcls_block</span> <span class="o">=</span> <span class="n">vols_star</span><span class="o">.</span><span class="n">identify_particles_data_block</span><span class="p">(</span><span class="n">column_substring</span><span class="o">=</span><span class="n">tomo_id_column</span><span class="p">)</span>
    <span class="n">df_vols</span> <span class="o">=</span> <span class="n">vols_star</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">vols_star_ptcls_block</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">df_vols</span><span class="p">[</span><span class="s1">&#39;_UnfilteredParticleInds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_vols</span><span class="p">))</span>
    <span class="n">df_vols</span> <span class="o">=</span> <span class="n">df_vols</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">df_merged</span><span class="p">[</span><span class="s1">&#39;_UnfilteredParticleInds&#39;</span><span class="p">]]</span>  <span class="c1"># internally map particle filtering applied at training time</span>

    <span class="c1"># filter out irrelevant columns from volumeseries star</span>
    <span class="n">cols_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df_vols</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">col_substring</span> <span class="ow">in</span> <span class="n">col</span> <span class="k">for</span> <span class="n">col_substring</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Coordinate&#39;</span><span class="p">,</span> <span class="s1">&#39;Angle&#39;</span><span class="p">,</span> <span class="n">tomo_id_column</span><span class="p">,</span> <span class="s1">&#39;_UnfilteredParticleInds&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="s1">&#39;Defocus&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col</span><span class="p">:</span>
            <span class="n">cols_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
    <span class="n">cols_to_drop</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">df_vols</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">cols_to_keep</span><span class="p">))</span>
    <span class="n">df_vols</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">cols_to_drop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># merge into df_merged</span>
    <span class="n">df_merged</span> <span class="o">=</span> <span class="n">df_merged</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_vols</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;_UnfilteredParticleInds&#39;</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;_img&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>

    <span class="c1"># generate recursive list of *.pkl files within cwd</span>
    <span class="n">paths_to_add</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cwd</span><span class="si">}</span><span class="s1">/**/*.pkl&#39;</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">paths_to_add</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">cwd</span><span class="p">)</span><span class="si">}</span><span class="s1">/z.</span><span class="si">{</span><span class="n">epoch</span><span class="si">}</span><span class="s1">.train.pkl&#39;</span><span class="p">)</span>
    <span class="n">known_column_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">data_pkl</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">()</span>  <span class="c1"># newline for visual separation of star file loading output from column name specification output</span>
    <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths_to_add</span><span class="p">:</span>

        <span class="c1"># load pkl</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">load_pkl</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># check if numpy array, skip if not</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># check if shape[0] matches length of star file, skip if not</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_ptcls</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># check that number of dimensions is at most 2 (not sure how to deal with ndarrays with 3+ axes), skip if so</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># log that this pkl file is being added to df_merged and log name format of added columns</span>
        <span class="n">column_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Mapping </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1"> to dataframe columns </span><span class="si">{</span><span class="n">column_names</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># sanity check that the proposed column name has not yet been created (which would cause naming conflict)</span>
        <span class="k">for</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">column_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="n">known_column_names</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: found duplicate column name </span><span class="si">{</span><span class="n">column_name</span><span class="si">}</span><span class="s1"> which is caused by two files sharing the same base filename: </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="n">known_column_names</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span><span class="si">}</span><span class="s1">. &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;Skipping values at </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">known_column_names</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>

        <span class="c1"># add new cols to df_merged corresponding to each column along dim[1] of array (e.g. z dimension 0, 1, 2, ...)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_names</span><span class="p">):</span>
            <span class="n">data_pkl</span><span class="p">[</span><span class="n">column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

    <span class="c1"># merge with df_merged</span>
    <span class="n">df_pkl</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data_pkl</span><span class="p">)</span>
    <span class="n">df_merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df_merged</span><span class="p">,</span> <span class="n">df_pkl</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_merged</span></div>



<span class="c1">##################################################</span>
<span class="c1"># Interactive 3-D particle and tomogram plotting #</span>
<span class="c1">##################################################</span>


<div class="viewcode-block" id="convert_angstroms_to_voxels">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.convert_angstroms_to_voxels.html#tomodrgn.analysis.convert_angstroms_to_voxels">[docs]</a>
<span class="k">def</span> <span class="nf">convert_angstroms_to_voxels</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                                <span class="n">tomogram_array_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                                <span class="n">tomo_pixelsize</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                <span class="n">starfile_pixelsize</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rescale dataframe coordinates from angstroms to unitless voxels corresponding to reconstructed tomograms.</span>
<span class="sd">    A starfile (loaded as a dataframe) expresses the 3-D coordinate of each particle typically in either ngstroms or in pixels (with a pixel size set at particle extraction time).</span>
<span class="sd">    In subsequent operations we will wish to plot particle locations superimposed on tomogram voxel data.</span>
<span class="sd">    This requires rescaling the particle coordinates from units of ngstroms or extraction-sized-pixels to tomogram-sized-voxels.</span>

<span class="sd">    :param df: dataframe containing particle coordinates to rescale</span>
<span class="sd">    :param tomogram_array_shape: shape of reconstructed tomogram in voxels</span>
<span class="sd">    :param tomo_pixelsize: pixel size of reconstructed tomogram in /px</span>
<span class="sd">    :param starfile_pixelsize: pixel size of particles at extraction time when writing the star file from which `df` was loaded.</span>
<span class="sd">            Note: star files produced from particle extraction in M always have pixel size 1 /px.</span>
<span class="sd">    :return: dataframe with rescaled coordinates aligned to the tomogram voxel array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># unpack the shape of the tomogram 3-D volume array</span>
    <span class="n">tomo_px_x</span><span class="p">,</span> <span class="n">tomo_px_y</span><span class="p">,</span> <span class="n">tomo_px_z</span> <span class="o">=</span> <span class="n">tomogram_array_shape</span>

    <span class="c1"># rlnCoordinate from starfile is measured in px, so needs to be rescaled to dimensionless tomo voxels</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;_rlnCoordinateX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;_rlnCoordinateX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">starfile_pixelsize</span> <span class="o">/</span> <span class="n">tomo_pixelsize</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;_rlnCoordinateY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;_rlnCoordinateY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">starfile_pixelsize</span> <span class="o">/</span> <span class="n">tomo_pixelsize</span>
    <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;_rlnCoordinateZ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;_rlnCoordinateZ&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">starfile_pixelsize</span> <span class="o">/</span> <span class="n">tomo_pixelsize</span>

    <span class="c1"># sanity check that all particle coordinates now fall within the tomogram voxel limits</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;_rlnCoordinateX&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">tomo_px_x</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;_rlnCoordinateY&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">tomo_px_y</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;_rlnCoordinateZ&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">tomo_px_z</span>

    <span class="k">return</span> <span class="n">df</span></div>



<div class="viewcode-block" id="ipy_tomo_ptcl_viewer">
<a class="viewcode-back" href="../../api/_autosummary/tomodrgn.analysis.ipy_tomo_ptcl_viewer.html#tomodrgn.analysis.ipy_tomo_ptcl_viewer">[docs]</a>
<span class="k">def</span> <span class="nf">ipy_tomo_ptcl_viewer</span><span class="p">(</span><span class="n">path_to_tomograms</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                         <span class="n">tomo_star_mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
                         <span class="n">tomo_id_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                         <span class="n">df_particles</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Box</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An interactive tomogram and particle viewer using plotly and ipywidgets.</span>
<span class="sd">    Allows correlation of tomogram image data with particle locations with particle metadata attributes expressed in ``df_particles``.</span>

<span class="sd">    :param path_to_tomograms: path to directory containing tomogram volumes</span>
<span class="sd">    :param tomo_star_mapping: dictionary mapping tomogram filenames to the corresponding string identifying each tomogram in the volumeseries star file `tomo_id_column` column</span>
<span class="sd">    :param tomo_id_column: name of the column within the volumeseries star file that contains unique values for each tomogram</span>
<span class="sd">    :param df_particles: pandas dataframe containing particle information to plot and colormap particles.</span>
<span class="sd">            Minimum required columns are [coordinate X, Y, and Z, tomo_id_column, &#39;_UnfilteredParticleInds&#39;]</span>
<span class="sd">    :return: ipywidgets.Box containing the interactive tomogram and particle viewer widget</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">TomoDataContainer</span><span class="p">:</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tomogram</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tomo_x_vx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tomo_x_ang</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tomo_y_vx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tomo_y_ang</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tomo_z_vx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tomo_z_ang</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df_particles_sub</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scatter_x_ang</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scatter_y_ang</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scatter_z_ang</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">tomo_load_callback</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the selected tomogram into memory and render it as image slices along the z axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">b</span>

        <span class="n">selected_tomogram</span> <span class="o">=</span> <span class="n">tomo_selection_widget</span><span class="o">.</span><span class="n">value</span>
        <span class="n">selected_tomogram</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_to_tomograms</span><span class="p">,</span> <span class="n">selected_tomogram</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">selected_tomogram</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Use the &quot;Tomogram:&quot; dropdown to select the tomogram to load&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading tomogram slices from </span><span class="si">{</span><span class="n">selected_tomogram</span><span class="si">}</span><span class="s1"> ...&#39;</span><span class="p">)</span>
        <span class="n">tomogram</span><span class="p">,</span> <span class="n">tomogram_header</span> <span class="o">=</span> <span class="n">mrc</span><span class="o">.</span><span class="n">parse_mrc</span><span class="p">(</span><span class="n">selected_tomogram</span><span class="p">)</span>
        <span class="n">tomo_angpix</span> <span class="o">=</span> <span class="n">tomogram_header</span><span class="o">.</span><span class="n">get_apix</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using tomogram shape: </span><span class="si">{</span><span class="n">tomogram</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using tomogram voxel size: </span><span class="si">{</span><span class="n">tomo_angpix</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># prepare bounds / meshes for tomogram rendering</span>
        <span class="n">tomo_z_vx</span><span class="p">,</span> <span class="n">tomo_y_vx</span><span class="p">,</span> <span class="n">tomo_x_vx</span> <span class="o">=</span> <span class="n">tomogram</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># tomo_mesh_z_vx, tomo_mesh_y_vx, tomo_mesh_x_vx = np.mgrid[0:tomo_x_vx, 0:tomo_y_vx, 0:tomo_z_vx]</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomogram</span> <span class="o">=</span> <span class="n">tomogram</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span> <span class="o">=</span> <span class="n">tomo_x_vx</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_ang</span> <span class="o">=</span> <span class="n">tomo_x_vx</span> <span class="o">*</span> <span class="n">tomo_angpix</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span> <span class="o">=</span> <span class="n">tomo_x_vx</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_ang</span> <span class="o">=</span> <span class="n">tomo_y_vx</span> <span class="o">*</span> <span class="n">tomo_angpix</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_vx</span> <span class="o">=</span> <span class="n">tomo_x_vx</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_ang</span> <span class="o">=</span> <span class="n">tomo_z_vx</span> <span class="o">*</span> <span class="n">tomo_angpix</span>

        <span class="c1"># graphical data</span>
        <span class="c1"># tomo_volume = go.Volume(</span>
        <span class="c1">#     name=&#39;tomo_volume&#39;,</span>
        <span class="c1">#     x=tomo_mesh_x_vx.flatten(),</span>
        <span class="c1">#     y=tomo_mesh_y_vx.flatten(),</span>
        <span class="c1">#     z=tomo_mesh_z_vx.flatten(),</span>
        <span class="c1">#     value=tomogram.flatten(),</span>
        <span class="c1">#     isomin=np.percentile(tomogram, 90),</span>
        <span class="c1">#     isomax=np.percentile(tomogram, 99),</span>
        <span class="c1">#     opacity=0.5,</span>
        <span class="c1">#     surface=dict(count=5),  # needs to be a large number for good volume rendering</span>
        <span class="c1">#     showscale=False,  # no colorbar</span>
        <span class="c1">#     # flatshading=False,</span>
        <span class="c1">#     # caps= dict(x_show=False, y_show=False, z_show=False),  # no caps</span>
        <span class="c1">#     visible=False,</span>
        <span class="c1"># )</span>

        <span class="n">tomo_slice</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Surface</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;tomo_slice&#39;</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span><span class="p">),</span>
            <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span><span class="p">),</span>
            <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">tomo_y_vx</span><span class="p">,</span> <span class="n">tomo_x_vx</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_ang</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">surfacecolor</span><span class="o">=</span><span class="n">tomogram</span><span class="p">[</span><span class="n">tomo_z_vx</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span>
            <span class="n">colorscale</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span>
            <span class="n">opacity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">showscale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># no colorbar</span>
        <span class="p">)</span>

        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_traces</span><span class="p">([</span>
                <span class="c1"># tomo_volume,</span>
                <span class="n">tomo_slice</span><span class="p">,</span>
            <span class="p">])</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">scatter_x_ang</span><span class="p">)],</span> <span class="p">),</span>
                <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">scatter_y_ang</span><span class="p">)],</span> <span class="p">),</span>
                <span class="n">zaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">scatter_z_ang</span><span class="p">)],</span> <span class="p">),</span>
                <span class="n">aspectratio</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="p">))</span>

        <span class="c1"># tomo_volume_iso_widget.min = np.min(tomogram)</span>
        <span class="c1"># tomo_volume_iso_widget.value = (np.percentile(tomogram, 90), np.percentile(tomogram, 99))</span>
        <span class="c1"># tomo_volume_iso_widget.max = np.max(tomogram)</span>

        <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomo_z_vx</span>
        <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">tomo_z_vx</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">tomo_slice_thickness_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomo_z_vx</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="n">tomo_slice_thickness_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done!&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ptcls_load_callback</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load two copies of the particles into the figure as a main scatter plot and a copy scatter plot for subset indication.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">b</span>

        <span class="n">selected_tomogram</span> <span class="o">=</span> <span class="n">tomo_selection_widget</span><span class="o">.</span><span class="n">value</span>
        <span class="n">selected_tomogram</span> <span class="o">=</span> <span class="n">tomo_star_mapping</span><span class="p">[</span><span class="n">selected_tomogram</span><span class="p">]</span>  <span class="c1"># tomo_selection_widget displays keys of a dict mapping tomogram file name on disk to tomogram name in star file / dataframe</span>
        <span class="k">if</span> <span class="n">selected_tomogram</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Use the &quot;Tomogram:&quot; dropdown to select the tomogram to load&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading particles from </span><span class="si">{</span><span class="n">selected_tomogram</span><span class="si">}</span><span class="s1"> ...&#39;</span><span class="p">)</span>

        <span class="n">df_particles_sub</span> <span class="o">=</span> <span class="n">df_particles</span><span class="p">[</span><span class="n">df_particles</span><span class="p">[</span><span class="n">tomo_id_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">selected_tomogram</span><span class="p">]</span>

        <span class="c1"># identify Coordinate column names</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">df_particles_sub</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pat</span><span class="o">=</span><span class="s1">&#39;_rlnCoordinate&#39;</span><span class="p">)):</span>
            <span class="c1"># column headers use relion/nextpyp naming</span>
            <span class="n">coords_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_rlnCoordinateX&#39;</span><span class="p">,</span> <span class="s1">&#39;_rlnCoordinateY&#39;</span><span class="p">,</span> <span class="s1">&#39;_rlnCoordinateZ&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">df_particles_sub</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">pat</span><span class="o">=</span><span class="s1">&#39;_wrpCoordinate&#39;</span><span class="p">)):</span>
            <span class="c1"># columns use warp/m naming</span>
            <span class="n">m_coords_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_name</span> <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">df_particles_sub</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s1">&#39;_wrpCoordinate&#39;</span> <span class="ow">in</span> <span class="n">col_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_coords_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># m temporal sampling == 1</span>
                <span class="n">coords_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_wrpCoordinateX&#39;</span><span class="p">,</span> <span class="s1">&#39;_wrpCoordinateY&#39;</span><span class="p">,</span> <span class="s1">&#39;_wrpCoordinateZ&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># m temporal sampling &gt; 1, have 3*temporal_sampling pose columns</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_coords_cols</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">coords_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_wrpCoordinateX1&#39;</span><span class="p">,</span> <span class="s1">&#39;_wrpCoordinateY1&#39;</span><span class="p">,</span> <span class="s1">&#39;_wrpCoordinateZ1&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not identify star file columns containing particle tomogram-level XYZ coordinates from columns: </span><span class="si">{</span><span class="n">df_particles</span><span class="o">.</span><span class="n">columns</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using coordinate columns: </span><span class="si">{</span><span class="n">coords_cols</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># identify Coordinate pixel size in angstroms</span>
        <span class="c1"># possibility that multiple columns contain the substring Pixel, therefore we take the largest pixel size value</span>
        <span class="c1"># assumption is that star file might contain original micrograph pixel size + extracted particle (binned) pixel size; we want the latter to correctly position particles</span>
        <span class="n">potential_pixel_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df_particles_sub</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="s1">&#39;Pixel&#39;</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">potential_pixel_columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">star_angpix</span> <span class="o">=</span> <span class="n">df_particles_sub</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">potential_pixel_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">star_angpix</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">df_particles_sub</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">potential_pixel_columns</span><span class="p">])</span>
        <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Using starfile pixel size: </span><span class="si">{</span><span class="n">star_angpix</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">df_particles_sub</span><span class="p">[</span><span class="n">coords_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_particles_sub</span><span class="p">[</span><span class="n">coords_cols</span><span class="p">]</span> <span class="o">*</span> <span class="n">star_angpix</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">df_particles_sub</span><span class="p">[</span><span class="n">coords_cols</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;_UnfilteredParticleInds&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">scatter_x_ang</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">scatter_y_ang</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">scatter_z_ang</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span> <span class="o">=</span> <span class="n">df_particles_sub</span>

        <span class="n">ptcls_scatter</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ptcls_scatter&#39;</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                <span class="n">opacity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">ptcl_marker_size_widget</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">hoverinfo</span><span class="o">=</span><span class="s1">&#39;text&#39;</span><span class="p">,</span>
            <span class="n">hovertext</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">df_particles_sub</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()]</span>
        <span class="p">)</span>

        <span class="n">ptcls_subset_scatter</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;subset_scatter&#39;</span><span class="p">,</span>
            <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;markers&#39;</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span>
                <span class="n">opacity</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">ptcl_subset_size_widget</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">visible</span><span class="o">=</span><span class="n">ptcl_subset_display_widget</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">hoverinfo</span><span class="o">=</span><span class="s1">&#39;text&#39;</span><span class="p">,</span>
            <span class="n">hovertext</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">df_particles_sub</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()]</span>
        <span class="p">)</span>

        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_traces</span><span class="p">([</span>
                <span class="n">ptcls_scatter</span><span class="p">,</span>
                <span class="n">ptcls_subset_scatter</span>
            <span class="p">])</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span><span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
                <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">scatter_x_ang</span><span class="p">)],</span> <span class="p">),</span>
                <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">scatter_y_ang</span><span class="p">)],</span> <span class="p">),</span>
                <span class="n">zaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">scatter_z_ang</span><span class="p">)],</span> <span class="p">),</span>
                <span class="n">aspectratio</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="p">))</span>

        <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Done!&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">continuous_update_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Toggle continuous updates for all continously interactive widgets (sliders)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="k">for</span> <span class="n">widget</span> <span class="ow">in</span> <span class="p">[</span>
            <span class="c1"># tomo_volume_iso_widget,</span>
            <span class="c1"># tomo_volume_opacity_widget,</span>
            <span class="n">tomo_slice_slider_widget</span><span class="p">,</span>
            <span class="n">tomo_slice_thickness_widget</span><span class="p">,</span>
            <span class="n">ptcl_marker_size_widget</span><span class="p">,</span>
            <span class="n">ptcl_subset_size_widget</span><span class="p">,</span>
            <span class="n">ptcl_subset_thresh_widget</span><span class="p">,</span>
        <span class="p">]:</span>
            <span class="n">widget</span><span class="o">.</span><span class="n">continuous_update</span> <span class="o">=</span> <span class="n">continuous_update_widget</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">reset_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the widget state by deleting tomogram from memory and removing figure traces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="n">tomodatacontainer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output</span><span class="o">.</span><span class="n">clear_output</span><span class="p">()</span>
        <span class="kn">import</span> <span class="nn">gc</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

    <span class="c1"># def tomo_volume_display_callback(event):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Update the figure to toggle visibility of the tomogram volume rendering</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if tomodatacontainer.tomogram.size &gt; 50**3:</span>
    <span class="c1">#         with output:</span>
    <span class="c1">#             print(f&#39;Caution: rendering volume with &gt; 50**3 elements can be very slow with plotly! Please wait ...&#39;)</span>
    <span class="c1">#     with fig.batch_update():</span>
    <span class="c1">#         fig.update_traces(visible=tomo_volume_display_widget.value, selector = ({&#39;name&#39;:&#39;tomo_volume&#39;}))</span>

    <span class="c1"># def tomo_volume_iso_callback(event):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Update the figure to render the tomogram volume with the selected minimum and maximum isosurface thresholds.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     with fig.batch_update():</span>
    <span class="c1">#         fig.update_traces(isomin=tomo_volume_iso_widget.value[0],</span>
    <span class="c1">#                            isomax=tomo_volume_iso_widget.value[1],</span>
    <span class="c1">#                           selector = ({&#39;name&#39;:&#39;tomo_volume&#39;}))</span>

    <span class="c1"># def tomo_volume_opacity_callback(event):</span>
    <span class="c1">#     with fig.batch_update():</span>
    <span class="c1">#         fig.update_traces(opacity=tomo_volume_opacity_widget.value, selector = ({&#39;name&#39;:&#39;tomo_volume&#39;}))</span>

    <span class="k">def</span> <span class="nf">tomo_slice_display_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the figure to toggle visibility of the tomogram slice rendering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">visible</span><span class="o">=</span><span class="n">tomo_slice_display_widget</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;tomo_slice&#39;</span><span class="p">}))</span>

    <span class="k">def</span> <span class="nf">tomo_slice_slider_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the figure to render the selected tomogram slice based on slice position, slice thickness, and active axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">tomo_slice_axis_widget</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="n">thickness</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tomo_slice_thickness_widget</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">thickness</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">plane_min</span> <span class="o">=</span> <span class="n">plane</span>
            <span class="n">plane_max</span> <span class="o">=</span> <span class="n">plane</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plane_min</span> <span class="o">=</span> <span class="n">plane</span> <span class="o">-</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">plane_max</span> <span class="o">=</span> <span class="n">plane</span> <span class="o">+</span> <span class="n">thickness</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="n">new_texture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomogram</span><span class="p">[</span><span class="n">plane_min</span><span class="p">:</span><span class="n">plane_max</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span><span class="p">),</span> <span class="n">plane</span> <span class="o">*</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_ang</span> <span class="o">/</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_vx</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">new_x</span><span class="p">,</span>
                                  <span class="n">y</span><span class="o">=</span><span class="n">new_y</span><span class="p">,</span>
                                  <span class="n">z</span><span class="o">=</span><span class="n">new_z</span><span class="p">,</span>
                                  <span class="n">surfacecolor</span><span class="o">=</span><span class="n">new_texture</span><span class="p">,</span>
                                  <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;tomo_slice&#39;</span><span class="p">}))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">new_texture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomogram</span><span class="p">[:,</span> <span class="n">plane_min</span><span class="p">:</span><span class="n">plane_max</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span><span class="p">,),</span> <span class="n">plane</span> <span class="o">*</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_ang</span> <span class="o">/</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span><span class="p">)</span>
            <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_vx</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">new_x</span><span class="p">,</span>
                                  <span class="n">y</span><span class="o">=</span><span class="n">new_y</span><span class="p">,</span>
                                  <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_z</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_x</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                  <span class="n">surfacecolor</span><span class="o">=</span><span class="n">new_texture</span><span class="p">,</span>
                                  <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;tomo_slice&#39;</span><span class="p">}))</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">new_texture</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomogram</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">plane_min</span><span class="p">:</span><span class="n">plane_max</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span><span class="p">,</span> <span class="n">plane</span> <span class="o">*</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_ang</span> <span class="o">/</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span><span class="p">)</span>
            <span class="n">new_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_ang</span><span class="p">,</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_vx</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">new_x</span><span class="p">,</span>
                                  <span class="n">y</span><span class="o">=</span><span class="n">new_y</span><span class="p">,</span>
                                  <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_z</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_y</span><span class="p">)),</span>
                                  <span class="n">surfacecolor</span><span class="o">=</span><span class="n">new_texture</span><span class="p">,</span>
                                  <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;tomo_slice&#39;</span><span class="p">}))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

    <span class="k">def</span> <span class="nf">tomo_slice_thickness_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the tomogram slice slider min and max to constrain allowable slices within tomogram volume bounds with new thickness.</span>
<span class="sd">        Then update the figure via `tomo_slice_slider_callback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="n">slice_thickness</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tomo_slice_thickness_widget</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">slice_thickness</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">tomo_slice_axis_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span> <span class="o">-</span> <span class="n">slice_thickness</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">tomo_slice_axis_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span> <span class="o">-</span> <span class="n">slice_thickness</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">tomo_slice_axis_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_vx</span> <span class="o">-</span> <span class="n">slice_thickness</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="n">tomo_slice_slider_callback</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tomo_slice_axis_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the tomogram slice slider max to constrain allowable slices within tomogram volume bounds with new axis.</span>
<span class="sd">        Update the tomogram thickness slider to constrain allowable thickness as less than the tomogram thickness along the new axis.</span>
<span class="sd">        Then update the figure via `tomo_slice_thickness_callback` which will further call `tomo_slice_slider_callback`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="k">if</span> <span class="n">tomo_slice_axis_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span>
            <span class="n">tomo_slice_thickness_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_x_vx</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">tomo_slice_axis_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span>
            <span class="n">tomo_slice_thickness_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="n">tomo_slice_axis_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_z_vx</span>
            <span class="n">tomo_slice_thickness_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">tomo_y_vx</span> <span class="o">//</span> <span class="mi">4</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="n">tomo_slice_thickness_callback</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ptcl_marker_display_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the figure to toggle visibility of the particles scatterplot rendering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">visible</span><span class="o">=</span><span class="n">ptcl_marker_display_widget</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ptcls_scatter&#39;</span><span class="p">}))</span>

    <span class="k">def</span> <span class="nf">ptcl_marker_size_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the particles scatter plot marker size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">ptcl_marker_size_widget</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">),</span> <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ptcls_scatter&#39;</span><span class="p">}))</span>

    <span class="k">def</span> <span class="nf">ptcl_colorby_column_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the particles scatter plot colors by passing the selected column&#39;s values to the selected colormap.</span>
<span class="sd">        Also updates the hovertext of each point to report the associated column value for that particle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="k">if</span> <span class="n">ptcl_colorby_column_widget</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;mediumturquoise&#39;</span><span class="p">),</span>
                              <span class="n">hovertext</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span>
                                         <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()],</span>
                              <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ptcls_scatter&#39;</span><span class="p">}))</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="p">[</span><span class="n">ptcl_colorby_column_widget</span><span class="o">.</span><span class="n">value</span><span class="p">]):</span>
            <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must choose a dataframe column with a numeric dtype.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">color_mapping</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="p">[</span><span class="n">ptcl_colorby_column_widget</span><span class="o">.</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">color_map</span> <span class="o">=</span> <span class="n">ptcl_colorby_colormap_widget</span><span class="o">.</span><span class="n">value</span>
        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="c1"># set hovertext for ptcls_scatter</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">color_mapping</span><span class="p">,</span>
                                          <span class="n">colorscale</span><span class="o">=</span><span class="n">color_map</span><span class="p">),</span>
                              <span class="n">hovertext</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">, color by value </span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span>
                                         <span class="nb">zip</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                                             <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="p">[</span>
                                                 <span class="n">ptcl_colorby_column_widget</span><span class="o">.</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())],</span>
                              <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;ptcls_scatter&#39;</span><span class="p">}))</span>
            <span class="c1"># duplicate hovertext for subset_scatter (otherwise hovering when subset_scatter shown overrides ptcls_scatter</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">color_mapping</span><span class="p">,</span>
                                          <span class="n">colorscale</span><span class="o">=</span><span class="n">color_map</span><span class="p">),</span>
                              <span class="n">hovertext</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">, color by value </span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span>
                                         <span class="nb">zip</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                                             <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="p">[</span>
                                                 <span class="n">ptcl_colorby_column_widget</span><span class="o">.</span><span class="n">value</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())],</span>
                              <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;subset_scatter&#39;</span><span class="p">}))</span>

    <span class="k">def</span> <span class="nf">ptcl_subset_display_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the figure to toggle visibility of the particles scatterplot subset rendering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">visible</span><span class="o">=</span><span class="n">ptcl_subset_display_widget</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;subset_scatter&#39;</span><span class="p">}))</span>

    <span class="k">def</span> <span class="nf">ptcl_subset_size_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the particles scatter plot subset marker size.</span>
<span class="sd">        If existing subset selection (via setting marker size per-particle) is in place, ensure that it is restored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">ptcl_subset_size_widget</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">),</span> <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;subset_scatter&#39;</span><span class="p">}))</span>
            <span class="n">ptcl_subset_thresh_callback</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ptcl_subset_column_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the particles scatter plot subset column by which to filter the subset selection.</span>
<span class="sd">        Adjust the extent of `ptcl_subset_thresh_widget` to min and max of selected column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="n">selected_column</span> <span class="o">=</span> <span class="n">ptcl_subset_column_widget</span><span class="o">.</span><span class="n">value</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="p">[</span><span class="n">selected_column</span><span class="p">]):</span>
            <span class="k">with</span> <span class="n">output</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must choose a dataframe column with a numeric dtype.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">old_min</span> <span class="o">=</span> <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">min</span>
        <span class="n">old_max</span> <span class="o">=</span> <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">max</span>
        <span class="n">new_min</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="p">[</span><span class="n">selected_column</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">new_max</span> <span class="o">=</span> <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="p">[</span><span class="n">selected_column</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">old_min</span> <span class="o">==</span> <span class="n">new_min</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">old_max</span> <span class="o">==</span> <span class="n">new_max</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">old_min</span><span class="p">,</span>
                                            <span class="n">new_min</span><span class="p">)</span>  <span class="c1"># update lower bound to temp value to avoid &quot;setting max &lt; min&quot; error</span>
        <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">min</span> <span class="o">=</span> <span class="n">new_min</span>
        <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">old_max</span><span class="p">,</span>
                                            <span class="n">new_max</span><span class="p">)</span>  <span class="c1"># update upper bound to temp value to avoid &quot;setting min &gt; max&quot; error</span>
        <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">new_max</span>
        <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_min</span><span class="p">,</span> <span class="n">new_max</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">ptcl_subset_thresh_callback</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the particles scatter plot subset markers to only show markers meeting thresholding criteria from `ptcl_subset_thresh_widget`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># this function must take a parameter for the callback to function, but we do not currently use it</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">event</span>

        <span class="c1"># get mask 0,1 of particles meeting threshold, depending on toggle of invert_thresh</span>
        <span class="n">subset_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="p">[</span><span class="n">ptcl_subset_column_widget</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">&gt;=</span>
                                <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span>
                                       <span class="n">tomodatacontainer</span><span class="o">.</span><span class="n">df_particles_sub</span><span class="p">[</span><span class="n">ptcl_subset_column_widget</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">&lt;=</span>
                                       <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">ptcl_subset_invert_thresh_widget</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="n">subset_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">subset_mask</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">fig</span><span class="o">.</span><span class="n">batch_update</span><span class="p">():</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_traces</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">ptcl_subset_size_widget</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">subset_mask</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span>
                              <span class="n">selector</span><span class="o">=</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;subset_scatter&#39;</span><span class="p">}))</span>

    <span class="c1"># TOMOGRAM / PARTICLES FIGURE LAYOUT</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">FigureWidget</span><span class="p">(</span><span class="n">layout</span><span class="o">=</span><span class="n">go</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span>
        <span class="n">autosize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span>
        <span class="n">scene</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">),</span>
            <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">),</span>
            <span class="n">zaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">),</span>
            <span class="n">aspectratio</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">xaxis</span><span class="o">=</span><span class="n">go</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">XAxis</span><span class="p">(</span><span class="n">linecolor</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mirror</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">yaxis</span><span class="o">=</span><span class="n">go</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">YAxis</span><span class="p">(</span><span class="n">linecolor</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mirror</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
        <span class="n">margin</span><span class="o">=</span><span class="n">go</span><span class="o">.</span><span class="n">layout</span><span class="o">.</span><span class="n">Margin</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span>
        <span class="n">dragmode</span><span class="o">=</span><span class="s1">&#39;orbit&#39;</span><span class="p">,</span>
    <span class="p">))</span>

    <span class="n">style</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;description_width&#39;</span><span class="p">:</span> <span class="s1">&#39;initial&#39;</span><span class="p">}</span>

    <span class="c1"># FIGURE INITIALIZATION CONTROLS</span>
    <span class="n">tomo_selection_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span>
        <span class="n">options</span><span class="o">=</span><span class="n">tomo_star_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Tomogram: &#39;</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">tomo_load_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Load tomogram&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">tomo_load_widget</span><span class="o">.</span><span class="n">on_click</span><span class="p">(</span><span class="n">tomo_load_callback</span><span class="p">)</span>
    <span class="n">ptcls_load_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Load particles&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcls_load_widget</span><span class="o">.</span><span class="n">on_click</span><span class="p">(</span><span class="n">ptcls_load_callback</span><span class="p">)</span>
    <span class="n">continuous_update_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Continuous figure updates&#39;</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">continuous_update_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">continuous_update_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">reset_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Button</span><span class="p">(</span>
        <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Reset widget&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">reset_widget</span><span class="o">.</span><span class="n">on_click</span><span class="p">(</span><span class="n">reset_callback</span><span class="p">)</span>

    <span class="c1"># # TOMOGRAM ISOSURFACE CONTROLS</span>
    <span class="c1"># tomo_volume_display_widget = widgets.Checkbox(</span>
    <span class="c1">#     value=False,</span>
    <span class="c1">#     style=style,</span>
    <span class="c1"># )</span>
    <span class="c1"># tomo_volume_display_widget.observe(tomo_volume_display_callback, names=[&#39;value&#39;])</span>
    <span class="c1"># tomo_volume_iso_widget = widgets.FloatRangeSlider(</span>
    <span class="c1">#     value=[0, 1],</span>
    <span class="c1">#     min=0,</span>
    <span class="c1">#     max=1,</span>
    <span class="c1">#     step=0.01,</span>
    <span class="c1">#     continuous_update=False,</span>
    <span class="c1">#     orientation=&#39;horizontal&#39;,</span>
    <span class="c1">#     readout=True,</span>
    <span class="c1">#     readout_format=&#39;.2f&#39;,</span>
    <span class="c1">#     style=style,</span>
    <span class="c1"># )</span>
    <span class="c1"># tomo_volume_iso_widget.observe(tomo_volume_iso_callback, names=[&#39;value&#39;])</span>
    <span class="c1"># tomo_volume_opacity_widget = widgets.FloatSlider(</span>
    <span class="c1">#     value=0.5,</span>
    <span class="c1">#     min=0,</span>
    <span class="c1">#     max=1,</span>
    <span class="c1">#     step=0.01,</span>
    <span class="c1">#     continuous_update=False,</span>
    <span class="c1">#     orientation=&#39;horizontal&#39;,</span>
    <span class="c1">#     readout=True,</span>
    <span class="c1">#     readout_format=&#39;.2f&#39;,</span>
    <span class="c1">#     style=style,</span>
    <span class="c1"># )</span>
    <span class="c1"># tomo_volume_opacity_widget.observe(tomo_volume_opacity_callback, names=[&#39;value&#39;])</span>

    <span class="c1"># TOMOGRAM SLICE CONTROLS</span>
    <span class="n">tomo_slice_display_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">tomo_slice_display_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">tomo_slice_display_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">tomo_slice_slider_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span>
        <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">continuous_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">tomo_slice_slider_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">tomo_slice_slider_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">tomo_slice_thickness_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span>
        <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">continuous_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">tomo_slice_thickness_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">tomo_slice_thickness_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">tomo_slice_axis_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span>
        <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">],</span>
        <span class="n">value</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">tomo_slice_axis_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">tomo_slice_axis_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>

    <span class="c1"># PARTICLE MARKER CONTROLS</span>
    <span class="n">ptcl_marker_display_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcl_marker_display_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">ptcl_marker_display_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">ptcl_marker_size_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
        <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">continuous_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
        <span class="n">readout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcl_marker_size_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">ptcl_marker_size_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">ptcl_colorby_column_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span>
        <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">]</span> <span class="o">+</span> <span class="n">df_particles</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcl_colorby_column_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">ptcl_colorby_column_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">ptcl_colorby_colormap_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span>
        <span class="n">options</span><span class="o">=</span><span class="n">pl_colors</span><span class="o">.</span><span class="n">named_colorscales</span><span class="p">(),</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcl_colorby_colormap_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">ptcl_colorby_column_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span>
        <span class="s1">&#39;value&#39;</span><span class="p">])</span>  <span class="c1"># shares the callback with ptcl_colorby_column_widget because intertwined functionality</span>
    <span class="n">ptcl_subset_display_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcl_subset_display_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">ptcl_subset_display_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">ptcl_subset_size_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">IntSlider</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
        <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
        <span class="n">continuous_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
        <span class="n">readout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcl_subset_size_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">ptcl_subset_size_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">ptcl_subset_column_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span>
        <span class="n">options</span><span class="o">=</span><span class="n">df_particles</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcl_subset_column_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">ptcl_subset_column_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">ptcl_subset_thresh_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">FloatRangeSlider</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">continuous_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span>
        <span class="n">readout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcl_subset_thresh_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">ptcl_subset_thresh_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
    <span class="n">ptcl_subset_invert_thresh_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Checkbox</span><span class="p">(</span>
        <span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ptcl_subset_invert_thresh_widget</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">ptcl_subset_thresh_callback</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>

    <span class="c1"># LOGGED OUTPUT</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Output</span><span class="p">()</span>

    <span class="c1"># WIDGET LAYOUT</span>
    <span class="n">controls_layout</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">justify_content</span><span class="o">=</span><span class="s1">&#39;space-around&#39;</span><span class="p">)</span>
    <span class="n">initialization_controls_container</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">tomo_selection_widget</span><span class="p">,</span>
                                                               <span class="n">tomo_load_widget</span><span class="p">,</span>
                                                               <span class="n">ptcls_load_widget</span><span class="p">,</span>
                                                               <span class="n">continuous_update_widget</span><span class="p">,</span>
                                                               <span class="n">reset_widget</span><span class="p">,</span> <span class="p">],</span>
                                                     <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;100%&#39;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="s1">&#39;inline-flex&#39;</span><span class="p">,</span>
                                                                           <span class="n">justify_content</span><span class="o">=</span><span class="s1">&#39;space-around&#39;</span><span class="p">,</span>
                                                                           <span class="n">border</span><span class="o">=</span><span class="s1">&#39;solid 1px&#39;</span><span class="p">))</span>
    <span class="c1"># tomo_volume_controls_container = widgets.VBox(children=[</span>
    <span class="c1">#     widgets.HBox(children=[widgets.Label(&#39;Display tomogram volume&#39;), tomo_volume_display_widget],</span>
    <span class="c1">#                  layout=controls_layout),</span>
    <span class="c1">#     widgets.HBox(children=[widgets.Label(&#39;tomo isosurface cutoffs&#39;), tomo_volume_iso_widget],</span>
    <span class="c1">#                  layout=controls_layout),</span>
    <span class="c1">#     widgets.HBox(children=[widgets.Label(&#39;tomo opacity&#39;), tomo_volume_opacity_widget], layout=controls_layout), ],</span>
    <span class="c1">#                                               layout=widgets.Layout(border=&#39;solid 1px&#39;))</span>
    <span class="n">tomo_slice_controls_container</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;Display tomogram slice&#39;</span><span class="p">),</span> <span class="n">tomo_slice_display_widget</span><span class="p">],</span>
                     <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;tomo slice position&#39;</span><span class="p">),</span> <span class="n">tomo_slice_slider_widget</span><span class="p">],</span> <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;tomo slice thickness&#39;</span><span class="p">),</span> <span class="n">tomo_slice_thickness_widget</span><span class="p">],</span>
                     <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;tomo slice axis&#39;</span><span class="p">),</span> <span class="n">tomo_slice_axis_widget</span><span class="p">],</span> <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">,</span> <span class="p">)],</span>
        <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">border</span><span class="o">=</span><span class="s1">&#39;solid 1px&#39;</span><span class="p">))</span>
    <span class="n">output_container</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">output</span><span class="p">],</span>
                                    <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">border</span><span class="o">=</span><span class="s1">&#39;solid 1px&#39;</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="s1">&#39;150px&#39;</span><span class="p">))</span>
    <span class="n">ptcls_controls_container</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;Display particles&#39;</span><span class="p">),</span> <span class="n">ptcl_marker_display_widget</span><span class="p">],</span> <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;particle size&#39;</span><span class="p">),</span> <span class="n">ptcl_marker_size_widget</span><span class="p">],</span> <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;particle color by&#39;</span><span class="p">),</span> <span class="n">ptcl_colorby_column_widget</span><span class="p">],</span> <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;particle color map&#39;</span><span class="p">),</span> <span class="n">ptcl_colorby_colormap_widget</span><span class="p">],</span>
                     <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span> <span class="p">],</span>
        <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">border</span><span class="o">=</span><span class="s1">&#39;solid 1px&#39;</span><span class="p">))</span>
    <span class="n">subset_controls_container</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;Display subset&#39;</span><span class="p">),</span> <span class="n">ptcl_subset_display_widget</span><span class="p">],</span> <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;subset size&#39;</span><span class="p">),</span> <span class="n">ptcl_subset_size_widget</span><span class="p">],</span> <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;subset select by&#39;</span><span class="p">),</span> <span class="n">ptcl_subset_column_widget</span><span class="p">],</span> <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;subset select cutoffs&#39;</span><span class="p">),</span> <span class="n">ptcl_subset_thresh_widget</span><span class="p">],</span>
                     <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span>
        <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">widgets</span><span class="o">.</span><span class="n">Label</span><span class="p">(</span><span class="s1">&#39;invert subset selection&#39;</span><span class="p">),</span> <span class="n">ptcl_subset_invert_thresh_widget</span><span class="p">],</span>
                     <span class="n">layout</span><span class="o">=</span><span class="n">controls_layout</span><span class="p">),</span> <span class="p">],</span>
        <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">border</span><span class="o">=</span><span class="s1">&#39;solid 1px&#39;</span><span class="p">))</span>
    <span class="n">runtime_controls_container</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span>  <span class="c1"># tomo_volume_controls_container,</span>
        <span class="n">tomo_slice_controls_container</span><span class="p">,</span>
        <span class="n">ptcls_controls_container</span><span class="p">,</span>
        <span class="n">subset_controls_container</span><span class="p">,</span>
        <span class="n">output_container</span><span class="p">],</span>
        <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;500px&#39;</span><span class="p">))</span>
    <span class="n">overall_widget</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">VBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">initialization_controls_container</span><span class="p">,</span>
                                            <span class="n">widgets</span><span class="o">.</span><span class="n">HBox</span><span class="p">(</span><span class="n">children</span><span class="o">=</span><span class="p">[</span><span class="n">runtime_controls_container</span><span class="p">,</span> <span class="n">fig</span><span class="p">],</span>
                                                         <span class="n">layout</span><span class="o">=</span><span class="n">widgets</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="s1">&#39;100%&#39;</span><span class="p">,</span>
                                                                               <span class="n">justify_content</span><span class="o">=</span><span class="s1">&#39;space-between&#39;</span><span class="p">))])</span>

    <span class="c1"># create holder for data</span>
    <span class="n">tomodatacontainer</span> <span class="o">=</span> <span class="n">TomoDataContainer</span><span class="p">()</span>

    <span class="c1"># DISPLAY FINAL WIDGET</span>
    <span class="k">return</span> <span class="n">overall_widget</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2024, Barrett M Powell, Joseph H Davis.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.0.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>